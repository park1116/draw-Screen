<!DOCTYPE html>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<head>
    <!--애니메이션 라이브러리-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.2/TweenMax.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.2/utils/Draggable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.34/browser.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.6.15/browser-polyfill.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.11/lodash.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>

    <!-- <script src="/js/TweenMax.min.js"></script> -->
    <!-- <script src="/js/Draggable.min.js"></script> -->
    <!-- <script src="/js/browser/browser.js"></script> -->
    <!-- <script src="/js/browser/browser-polyfill.min.js"></script> -->
    <!-- <script src="/js/lodash.min.js"></script> -->
    <!-- <script src="/js/jquery/jquery-3.2.1.min.js"></script> -->
    <style>
        body,
        html {
            height: 100%;
            overflow: hidden;
            background: #dfdfdf;
        }

        #svg {
            font-family: Arial, sans-serif;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* scroll 생성 */
        .svgScroll {
            position: relative;
            width: 100%;
            height: 100%;
            overflow-y: auto;
        }

        .node-container {
            cursor: move;
        }

        .node-background {
            fill: #dfe0e8;
        }

        .node-header {
            fill: #396aa4;
        }

        .node-header .header-title {
            font-size: 13px;
            fill: #fff;
            text-anchor: middle;
        }

        .node-content {
            fill: #eff0f6;
        }

        .port {
            cursor: pointer;
        }

        .port-scrim {
            fill: transparent;
        }

        .port-outer {
            fill: #777777;
        }

        .port-inner {
            fill: #202020;
        }

        .port-label {
            font-size: 12px;
            fill: #484848;
        }

        .port-label[x="28"] {
            cursor: pointer;
        }

        .tableport {
            cursor: pointer;
        }

        .tableport-scrim {
            fill: transparent;
        }

        .tableport-outer {
            fill: #777777;
        }

        .tableport-inner {
            fill: #202020;
        }

        .tableconnector-handle {
            fill: #0b396c;
        }

        .tableconnector-path {
            stroke: #0b396c;
            stroke-width: 4;
            fill: none;
        }

        .tableconnector-path-outline {
            stroke: #333;
            stroke-width: 6;
            fill: none;
        }

        .input-field .port-label {
            text-anchor: start;
        }

        .output-field .port-label {
            text-anchor: end;
        }

        .port-title {
            font-size: 12px;
            fill: #426DCA;
            font-weight: 800;
        }

        .input-title .port-title {
            text-anchor: start;
        }

        .output-title .port-title {
            text-anchor: end;
        }

        .connector-handle {
            fill: #99a7bc;
        }

        .connector-path {
            stroke: #99a7bc;
            stroke-width: 4;
            fill: none;
        }

        .connector-path-outline {
            stroke: #333;
            stroke-width: 6;
            fill: none;
        }

        #my_modal {
            display: none;
            background-color: #fefefe;
            border: 1px solid #888;
            border-radius: 3px;
        }
    </style>
    <script>
        window.onresize = function () {
            // scroll을 브라우저의 크기에 맞추는 동작 ("-50" 하는 부분은 상단에 selectbox가 있는 div부분의 높이)
            document.getElementById("svgScroll").style.height = 100 + "%";
            document.getElementById("svgScroll").style.height = (document.getElementById("svgScroll").offsetHeight - 50) + "px";
        };

        window.onload = function () {
            // scroll을 브라우저의 크기에 맞추는 동작 ("-50" 하는 부분은 상단에 selectbox가 있는 div부분의 높이)
            document.getElementById("svgScroll").style.height = (document.getElementById("svgScroll").offsetHeight - 50) + "px";

            // 클릭 이벤트 설정
            clickEvent();
         
            // keydown 이벤트 설정
            keyupEvent();

            // svg element 생성시 필요한 인수값
            var svgUrl = "http://www.w3.org/2000/svg";

            // 인터페이스 목록 조회
            getListServer();

            // 인터페이스 목록 조회 서비스
            function getListServer() {
                $.ajax(
                    { url: '/dbcolumn', type: 'post', async: false, success: successCall, error: errorCall }
                );

                function successCall(s) {
                    console.log("getListSuccess");
                    console.log(s);

                    createList(s);
                }

                function errorCall(e) {
                    console.log("getListError");
                    console.log(e);
                }
            };

            // 화면에 인터페이스 리스트 생성
            function createList(listData) {
                // {"sendChannelGroupId":"K4M","interfaceId":"IF_K4M_KR_D005","receiveChannelGroupId":"KR","receiveAdapterServiceId":"DB.IFReceiver.IF_K4M_KR_D005"};
                let datalist = document.getElementById('interfaceList');

                for (let l = 0; l < listData.interfaceList.length; l++) {
                    let opt = document.createElement("option");

                    //interfaceType이 DB2DB이고 다른 값들이 모두 존재할 경우에만 interface 목록에 추가
                    if (listData.interfaceList[l].receiveChannelGroupId !== "" && listData.interfaceList[l].fromChannelGroupId !== "" && listData.interfaceList[l].interfaceType == "DB2DB" && listData.interfaceList[l].interfaceId !== "" && listData.interfaceList[l].receiveAdapterId !== "") {

                        // interface목록을 opt 객체에 담아서 리스트 형식으로 표현
                        opt.setAttribute('receiveChannelGroupId', listData.interfaceList[l].receiveChannelGroupId);
                        opt.setAttribute('fromChannelGroupId', listData.interfaceList[l].fromChannelGroupId);
                        opt.setAttribute('interfaceType', listData.interfaceList[l].interfaceType);
                        opt.setAttribute('value', listData.interfaceList[l].interfaceId);
                        opt.setAttribute('receiveAdapterId', listData.interfaceList[l].receiveAdapterId);
                        datalist.appendChild(opt);

                    }
                }
            };

            // 선택된 인터페이스 조회
            updateInputValue();

            // 인터페이스 선택시 update 이벤트
            function updateInputValue() {
                // 인터페이스 검색 input element
                var inputEl = document.getElementsByClassName('interfaceListInput')[0];
                // input element에 input속성 updateValue이벤트 등록
                inputEl.addEventListener('input', updateValue);

                function updateValue(e) {
                    // 인터페이스에 해당하는 내용 조회 유무 판단 flag
                    let cnt = -1;

                    // 인터페이스 검색 input element 값을 option에 등록된 인터페이스 목록과 비교
                    interfaceId = e.target.value;
                    let opts = document.getElementsByTagName('option');
                    for (let i = 0; i < opts.length; i++) {
                        if (interfaceId == opts[i].getAttribute('value')) {
                            cnt = i;
                            break;
                        }
                    }

                    // 조회된 인터페이스 목록이 없을 경우 튕겨냄
                    if (cnt == -1) {
                        return true;
                    }

                    // output, input, connector, tableconnector 초기화
                    cleanElement();

                    // 선택된 인터페이스에서 상세 조회에 필요한 값 추출
                    let receiveChannelGroupId = opts[cnt].getAttribute('receiveChannelGroupId');
                    let fromChannelGroupId = opts[cnt].getAttribute('fromChannelGroupId');
                    let interfaceType = opts[cnt].getAttribute('interfaceType');
                    let receiveAdapterId = opts[cnt].getAttribute('receiveAdapterId');

                    // 상세 조회에 필요한 값 null 체크
                    if (receiveChannelGroupId !== "" && fromChannelGroupId !== "" && interfaceType !== "" && interfaceId !== "" && receiveAdapterId !== "") {

                        // 인터페이스 상세 조회
                        requestServer(receiveChannelGroupId, fromChannelGroupId, interfaceId, receiveAdapterId);

                        // 변수 초기화
                        initData();

                        // 화면 그리기
                        const diagram = new Diagram();

                        // 상세 조회 후 숨겨진 svg 보여지도록 속성 변경
                        document.getElementsByTagName('svg')[0].setAttribute('style', 'visibility: visible');

                        // 상세 조회 후 숨겨진 button 보여지도록 속성 변경
                        document.getElementById('saveBtn').setAttribute('style', 'visibility: visible');
                        document.getElementById('clearBtn').setAttribute('style', 'visibility: visible');
                    }
                }
            };

            // 기존에 그려진 화면 지우기 함수
            function cleanElement() {
                let outs = document.getElementsByClassName('outputs');
                let ins = document.getElementsByClassName('inputs');
                let cons = document.getElementById('connections-layer');
                let tcons = document.getElementById('tableconnections-layer');

                for (let i = 0; i < 2; i++) {
                    while (outs[i].hasChildNodes()) {
                        outs[i].removeChild(outs[i].firstChild);
                    }
                    if (i == 0) {
                        while (ins[i].hasChildNodes()) {
                            ins[i].removeChild(ins[i].firstChild);
                        }
                    }
                }

                while (cons.hasChildNodes()) {
                    cons.removeChild(cons.firstChild);
                }

                while (tcons.hasChildNodes()) {
                    tcons.removeChild(tcons.firstChild);
                }
            };

            function requestServer(receiveChannelGroupId, fromChannelGroupId, interfaceId, receiveAdapterId) {

                mappingData = "";
                sendTableNames = "";

                // {sendChannelGroupId: sendChannelGroupId, interfaceId: interfaceId, receiveChannelGroupId: receiveChannelGroupId, receiveAdapterServiceId: receive} 
                // var reqData = {"sendChannelGroupId":"K4M","interfaceId":"IF_K4M_KR_D005","receiveChannelGroupId":"KR","receiveAdapterServiceId":"DB.IFReceiver.IF_K4M_KR_D005"};
                var reqData = {
                    "sendChannelGroupId": fromChannelGroupId,
                    "interfaceId": interfaceId,
                    "receiveChannelGroupId": receiveChannelGroupId,
                    "receiveAdapterServiceId": receiveAdapterId
                };

                $.ajax({
                    url: 'interface/mappingprocess',
                    type: 'post',
                    data: reqData,
                    async: false,
                    success: successCall,
                    error: errorCall
                });

                function successCall(s) {
                    console.log("RequestSuccess");
                    console.log(s);
                    setNode(s.send, "send");
                    setNode(s.receive, "receive");

                    sendTableNames = s.receive.sendTableNames;

                    if (s.hasOwnProperty('mappingData') && s.mappingData.length > 0) {
                        mappingData = s.mappingData;
                    }

                    return true;
                }

                function errorCall(e) {
                    console.log("RequestError");
                    console.log(e);

                    return false;
                }
            };


            // 동적 생성 data : requestServer함수로 interface명 조회 결과값 sendOrReceive : send 데이터 또는
            // receive 데이터 설정
            function setNode(data, sendOrReceive) {

                let createData = data;
                let headerTitle;
                let createDataColumns;

                // 송/수신 어뎁터서비스 아이디 설정 및 컬럼 설정
                if (sendOrReceive == "send") {
                    headerTitle = createData.sendAdapterServiceId;
                    createDataColumns = createData.sendColumns;
                } else {
                    headerTitle = createData.receiveAdapterServiceId;
                    createDataColumns = createData.receiveColumns;
                }

                // 테이블 갯수 체크
                let tableCnt = createData.tableNames.length;
                let columnsCnt = 0;

                // 모든 컬럼 갯수 체크
                for (let col = 0; col < tableCnt; col++) {
                    columnsCnt += createDataColumns[col].length;
                }

                // shape 총 높이 설정 header: 40, content: (15 * (tableCnt + columnsCnt)) + (10 *
                // (tableCnt + columnsCnt + 1)), 여백: (상단:2, 중단:2, 하단:2)
                let totalHeight = 40 + (15 * (tableCnt + columnsCnt)) + (10 * (tableCnt + columnsCnt + 1)) + 6;
                // header, 여백 제외한 content 총 높이 설정
                let contentHeight = (15 * (tableCnt + columnsCnt)) + (10 * (tableCnt + columnsCnt + 1));

                let line = null;
                let lineCheck = null;
                let inAndOut = null;
                let inAndOutCheck = null;

                // shape content 영역 높이 설정 변수
                let tempContentHeight = 0;

                if (sendOrReceive == "send") {

                    // 왼쪽 out lineCheck = "0";
                    lineCheck = "0";
                    inAndOutCheck = "out";

                    tempContentHeight = contentHeight;

                    //1번째 shape size 설정
                    setSizeNode(0, totalHeight, contentHeight, headerTitle);

                } else {
                    // 오른쪽 in/out lineCheck = "0|1"; 송신 데이터(in) = lineCheck:0, inAndOutCheck:in
                    // 수신(out) = lineCheck:1, inAndOutCheck:out inAndOutCheck = "in|out";
                    lineCheck = "0|1"
                    inAndOutCheck = "in|out";

                    if (tempContentHeight > contentHeight) {
                        contentHeight = tempContentHeight;
                    }

                    //2번째 shap size 설정
                    setSizeNode(1, totalHeight, contentHeight, headerTitle);
                }

                let cnt = 0;

                line = lineCheck.split('|');
                inAndOut = inAndOutCheck.split('|')

                let currentTableName = "";

                // line 설정
                for (let a = 0; a < line.length; a++) {
                    cnt = 0;
                    // table 설정
                    for (let b = 0; b < tableCnt; b++) {
                        createNode(createData.tableNames[b], inAndOut[a], cnt, false, line[a]);
                        cnt++;
                        // table에 해당하는 column 설정
                        for (let c = 0; c < createDataColumns[b].length; c++) {
                            createNode(createDataColumns[b][c], inAndOut[a], cnt, true, line[a]);
                            cnt++;
                        }
                    }
                }
            };

            function setSizeNode(position, totalHeight, contentHeight, serviceId) {
                //높이 설정
                document.getElementsByClassName('node-background')[position].setAttribute('height', totalHeight);

                document.getElementsByClassName('content-round-rect')[position].setAttribute('height', contentHeight);

                document.getElementsByClassName('content-rect')[position].setAttribute('height', contentHeight - 5);

                //타이틀 변경
                document.getElementsByClassName('header-title')[position].innerHTML = serviceId;

                //타이틀 가운데 정렬을 위해서 transform 속성 설정
                if (position == 1) {
                    document.getElementsByClassName('header-title')[position].setAttribute('transform', "translate(298, 0)");
                } else {
                    document.getElementsByClassName('header-title')[position].setAttribute('transform', "translate(5, 0)");
                }
            };

            function createNode(name, inAndOut, position, checkData, line) {
                let labelX = '0';
                let portX = '0';
                let port = document.createElementNS(svgUrl, "g");
                let portOuter = document.createElementNS(svgUrl, "circle");
                let portInner = document.createElementNS(svgUrl, "circle");
                let portScrim = document.createElementNS(svgUrl, "circle");

                // 0, 1번째 out / 0번째 in label, port 위치 설정
                if (inAndOut == "out") {
                    if (line == 0) {
                        labelX = '226';
                        portX = '239';
                    } else {
                        labelX = '846';
                        portX = '859';
                    }
                } else {
                    labelX = '28';
                    portX = '15';
                }

                if (checkData) {
                    //column명 일 경우
                    let field = document.createElementNS(svgUrl, "g");
                    let label = null;

                    //field 설정
                    document.getElementsByClassName(inAndOut + 'puts')[line].appendChild(field);
                    field.setAttribute('class', inAndOut + 'put-field');
                    field.setAttribute('transform', 'translate(0, ' + parseInt(50 + (25 * position)) + ')');

                    let putField = document.getElementsByClassName(inAndOut + 'put-field');

                    //port 설정
                    document.getElementsByClassName(inAndOut + 'put-field')[putField.length - 1].appendChild(port);
                    port.setAttribute('class', 'port');

                    //label 설정
                    label = document.createElementNS(svgUrl, "text");
                    label.innerHTML = name;

                    document.getElementsByClassName(inAndOut + 'put-field')[putField.length - 1].appendChild(label);
                    label.setAttribute('class', 'port-label');
                    label.setAttribute('x', labelX);
                    label.setAttribute('y', '14');

                    //portOuter 설정
                    document.getElementsByClassName(inAndOut + 'put-field')[putField.length - 1].children[0].appendChild(portOuter);
                    portOuter.setAttribute('class', 'port-outer');
                    portOuter.setAttribute('cx', portX);
                    portOuter.setAttribute('cy', '10');
                    portOuter.setAttribute('r', '7.5');

                    //portInner 설정
                    document.getElementsByClassName(inAndOut + 'put-field')[putField.length - 1].children[0].appendChild(portInner);
                    portInner.setAttribute('class', 'port-inner');
                    portInner.setAttribute('cx', portX);
                    portInner.setAttribute('cy', '10');
                    portInner.setAttribute('r', '5');

                    //portScrim 설정
                    document.getElementsByClassName(inAndOut + 'put-field')[putField.length - 1].children[0].appendChild(portScrim);
                    portScrim.setAttribute('class', 'port-scrim');
                    portScrim.setAttribute('cx', portX);
                    portScrim.setAttribute('cy', '10');
                    portScrim.setAttribute('r', '7.5');
                    portScrim.setAttribute('table', currentTableName);
                    portScrim.setAttribute('columnName', name);
                    portScrim.setAttribute('initCol', name);
                } else {
                    //table명 일 경우
                    let title = document.createElementNS(svgUrl, "g");
                    document.getElementsByClassName(inAndOut + 'puts')[line].appendChild(title);
                    title.setAttribute('class', inAndOut + 'put-title');
                    title.setAttribute('transform', 'translate(0, ' + parseInt(50 + (25 * position)) + ')');

                    let titleLabel = document.createElementNS(svgUrl, "text");
                    titleLabel.setAttribute('class', 'port-title');
                    titleLabel.setAttribute('x', labelX);
                    titleLabel.setAttribute('y', '14');

                    let len = document.getElementsByClassName(inAndOut + 'put-title').length;
                    document.getElementsByClassName(inAndOut + 'put-title')[len - 1].appendChild(titleLabel);
                    titleLabel.innerHTML = name;
                    currentTableName = name;

                    //tableport 설정
                    document.getElementsByClassName(inAndOut + 'put-title')[len - 1].appendChild(port);
                    port.setAttribute('class', 'tableport');

                    //tableportOuter 설정
                    document.getElementsByClassName(inAndOut + 'put-title')[len - 1].children[1].appendChild(portOuter);
                    portOuter.setAttribute('class', 'tableport-outer');
                    portOuter.setAttribute('cx', portX);
                    portOuter.setAttribute('cy', '10');
                    portOuter.setAttribute('r', '7.5');

                    //tableportInner 설정
                    document.getElementsByClassName(inAndOut + 'put-title')[len - 1].children[1].appendChild(portInner);
                    portInner.setAttribute('class', 'tableport-inner');
                    portInner.setAttribute('cx', portX);
                    portInner.setAttribute('cy', '10');
                    portInner.setAttribute('r', '5');

                    //tableportScrim 설정
                    document.getElementsByClassName(inAndOut + 'put-title')[len - 1].children[1].appendChild(portScrim);
                    portScrim.setAttribute('class', 'tableport-scrim');
                    portScrim.setAttribute('cx', portX);
                    portScrim.setAttribute('cy', '10');
                    portScrim.setAttribute('r', '7.5');
                    portScrim.setAttribute('table', name);
                }

                // 가장 우측에 그려지는 부분의 port는 전부 hidden 처리
                if (inAndOut == "out" && line == "1") {
                    portOuter.setAttribute('style', 'visibility: hidden;');
                    portInner.setAttribute('style', 'visibility: hidden;');
                    portScrim.setAttribute('style', 'visibility: hidden;');
                }
            };

            // Chrome 48에서 더 이상 사용되지 않는 getTransformToElement에 대한 Polyfill은 이제
            // globalToLocal을 단순화하고 polyfill을 생략 할 수 있습니다.
            SVGElement.prototype.getTransformToElement = SVGElement.prototype.getTransformToElement || function (toElement) {
                return toElement.getScreenCTM().inverse().multiply(this.getScreenCTM());
            };

            function clickEvent() {
                let checkClickEvent = document;
                let clickEl = "";

                checkClickEvent.addEventListener('click', function (event) {

                	// port 클릭시 생성되는 connector(점)을 제거 하기 위함 port에 connector가 존재할 때 port-inner 부분 클릭시
                    // (event.target : connector-handle) port에 connector가 없을 때 port-inner 부분 클릭시
                    // (event.target : diagram) port의 port-scrim 부분 클릭시 (event.target : port-scrim)
                    // text 클릭시 (event.target : port-title, port-label) 위 4가지 경우에 생성되는 점 모양의 connector 제거
                    if ((event.target.hasAttribute('class') && event.target.getAttribute('class').indexOf('connector-') > -1) ||
                        (event.target.hasAttribute('id') && event.target.getAttribute('id').indexOf('diagram') > -1) ||
                        ((event.target.hasAttribute('class') && event.target.getAttribute('class').indexOf('port-scrim') > -1) && (event.target.hasAttribute('connectors') == false || event.target.hasAttribute('connectors') && event.target.getAttribute('connectors') == "")) ||
                        (event.target.hasAttribute('class') && event.target.getAttribute('class').indexOf('tableconnector-') > -1) ||
                        ((event.target.hasAttribute('class') && event.target.getAttribute('class').indexOf('tableport-scrim') > -1) && (event.target.hasAttribute('tableconnectors') == false || event.target.hasAttribute('tableconnectors') && event.target.getAttribute('tableconnectors') == "")) ||
                        (event.target.hasAttribute('class') && event.target.getAttribute('class').indexOf('title') > -1 && event.target.parentElement.getAttribute('class').indexOf('out') > -1) ||
                        (event.target.hasAttribute('class') && event.target.getAttribute('class').indexOf('label') > -1 && event.target.parentElement.getAttribute('class').indexOf('out') > -1)) {

                        connectorClean();
                        tableconnectorClean();

                        // 현재 사용중인 connector id
                        let currentId = $('.connector').last().attr('id');

                        let idx = saveThisList.findIndex(function (item) {
                            return item.id === currentId
                        });

                        if (idx > -1) {
                            let data = saveThisList[idx];
                            rename(data, "change");
                        }

                        // 현재 사용중인 tableconnector id
                        let currentTableId = $('.tableconnector').last().attr('id');
                        let tidx = saveTableThisList.findIndex(function (item) {
                            return item.id === currentId
                        });
                        if (tidx > -1) {
                            let tdata = saveTableThisList[tidx];
                            tablerename(tdata, "change");
                        }

                    } else if (event.target.hasAttribute('class') && event.target.getAttribute('class').indexOf('label') > -1 && event.target.parentElement.getAttribute('class').indexOf('in') > -1) {
                        viewModal(event.target);
                    } else if (event.target.tagName == 'tspan') {
                        viewModal(event.target.parentElement);
                    }
                });
            }

            function keyupEvent() {
                let keyupEvent = document;

                keyupEvent.addEventListener('keyup', function (event) {
                    if (event.target.hasAttribute('class') && event.target.getAttribute('class').indexOf('edit') > -1) {
                        editText();
                    }
                });
            }

            function initData() {

                renameCheck = true;
                outportId = "";
                autoCon = false;
                dragYN = true;
                inputPortMapping = false;
                saveThisList = [];
                startInputPort = false;
                // inputPortList = [];
                outputPortList = [];
                nextUidPort = 0;
                nextUidConnector = 0;
                nextUidShape = 0;

                shapeLookup = {};
                shapes = [];

                portLookup = {};
                ports = [];

                // tableport 변수 초기화
                tableportLookup = {};
                tableports = [];
                nextUidTablePort = 0;
                // tableconnector 변수 초기화
                nextUidTableConnector = 0;
                saveTableThisList = [];
                tableconnectorLookup = {};
                tableconnectorPool = [];
                inputTablePortMapping = false;
                outputTablePortList = [];

                connectorLookup = {};
                connectorPool = [];

            }

            //
            // APP
            // ===========================================================================

            initDiagram = {};

            // var tempContentHeight = 0; connector 맵핑 정보 저장 변수
            mappingData = "";

            // 인터페이스 아이디
            interfaceId = "";

            // 수신 테이블에 맵핑된 송신 테이블명
            sendTableNames = "";

            //rename 함수 flag 설정
            renameCheck = true;

            //path 선택시 outportId 설정
            outportId = "";

            //createAutoConnector 대상 유무 확인
            autoCon = false;

            //drag 대상 유무 확인
            dragYN = true;

            //inputPort 맵핑 여부 판단 변수
            inputPortMapping = false;

            //this 저장 변수
            saveThisList = [];

            //InputPort 시작 여부
            startInputPort = false;

            //inputport 리스트 배열 var inputPortList = []; outport 리스트 배열
            outputPortList = [];

            // port id 값 설정
            nextUidPort = 0;

            // connector id 값 설정
            nextUidConnector = 0;

            // shape id 값 설정
            nextUidShape = 0;

            // scroll 움직임을 계산하기 위한 기준값
            preScroll = 0;

            // updatePath() 함수에서 사용하는 고정 연산값
            bezierWeight = 0.675;

            svg = document.querySelector("#svg");

            diagramElement = document.querySelector("#diagram");

            // shape object 저장변수
            shapeLookup = {};
            // shape 배열 저장변수
            shapes = [];

            // portLookup object 저장변수
            portLookup = {};
            // ports 배열 저장변수
            ports = [];

            // connectorLookup object 저장변수
            connectorLookup = {};
            // connectorPool object 저장변수
            connectorPool = [];

            // tableportLookup object 저장변수
            tableportLookup = {};
            // tableports 배열 저장변수
            tableports = [];
            // tableport id 값 설정
            nextUidTablePort = 0;
            // tableconnector id 값 설정
            nextUidTableConnector = 0;
            //this 저장 변수
            saveTableThisList = [];
            // tableconnectorLookup object 저장변수
            tableconnectorLookup = {};
            // tableconnectorPool object 저장변수
            tableconnectorPool = [];
            //inputPort 맵핑 여부 판단 변수
            inputTablePortMapping = false;
            //outport 리스트 배열
            outputTablePortList = [];

            // click한 컬럼
            nowClickColumn = "";

            // 컬럼 앞에 붙는 공통 데이터
            preAddText = '';
            // 컬럼 뒤에 붙는 공통 데이터
            postAddText = '';

            dragProxy = document.querySelector("#drag-proxy");
            shapeElements = Array.prototype.slice.call(document.querySelectorAll(".node-container"));

            frag = document.createDocumentFragment();
            frag.appendChild(document.querySelector(".connector"));
            connectorElement = frag.querySelector(".connector");
            connectorLayer = document.querySelector("#connections-layer");

            tablefrag = document.createDocumentFragment();
            tablefrag.appendChild(document.querySelector(".tableconnector"));
            tableconnectorElement = tablefrag.querySelector(".tableconnector");
            tableconnectorLayer = document.querySelector("#tableconnections-layer");
        };

        //
        // DIAGRAM
        // ===========================================================================
        class Diagram {

            constructor() {

                //diagram element
                this.dragElement = this.element = diagramElement;

                let tablePos = 0;

                // viewBox를 동적으로 그리기 위한 변수
                let x = 0;
                let y = 0;

                shapeElements.forEach((element, i) => {
                    const shape = new NodeShape(element, 50 + i * 300 + (tablePos * 200), 20);
                    shapeLookup[shape.id] = shape;
                    shapes.push(shape);

                    //테이블 넓이에 따라서 위지 수정
                    let tableWidth = element.children[0].getAttribute('width');
                    tablePos = Math.floor(tableWidth / 200) - 1;

                    let tableHeight = element.children[0].getAttribute('height');

                    // viewBox의 동적으로 변화하는 y값 ("+50" 하는 부분은 상단에 selectbox가 있는 div부분의 높이)
                    y = y >= (Math.floor(tableHeight) + 50) ? y : (Math.floor(tableHeight) + 50);
                });
                // viewBox의 동적으로 변화하는 x값
                x = 50 + shapeElements.length * 300 + (tablePos * 200);

                this.target = null;
                this.dragType = null;

                this.dragTarget = this.dragTarget.bind(this);
                this.prepareTarget = this.prepareTarget.bind(this);
                this.stopDragging = this.stopDragging.bind(this);

                //Draggable.min.js
                this.draggable = new Draggable(dragProxy, {
                    allowContextMenu: true,
                    trigger: svg,
                    onDrag: this.dragTarget,
                    onDragEnd: this.stopDragging,
                    onPress: this.prepareTarget
                });

                //diagram 초기 this값 설정
                initDiagram = this;

                createAutoConnector(this, false);

                // 최초 생성된(자동으로 그려졌는지 유무) connector 유무 확인 flag
                autoCon = false;

                // svg의 viewBox 속성값을 그려지는 그림에 따라서 동적으로 저장
                document.getElementsByTagName('svg')[0].setAttribute('viewBox', '0 0 ' + x + ' ' + y);
            }

            // drag stop할 때 진행
            stopDragging(event) {
                this.target.onDragEnd && this.target.onDragEnd();
            }

            // drag target 지정시 진행
            prepareTarget(event) {
                // target 재설정 변수
                let elCheck = "";
                // output 재설정 변수
                let outputCheck = false;
                // outportId 변수 초기화
                outportId = "";
                // preScroll 변수 초기화
                preScroll = document.getElementById("svgScroll").scrollTop;

                // event.target이 path, circle일 경우
                let connectorId = "";

                // event.target이 table명 관련 path, circle일 경우
                let tableconnectorId = "";

                if (event.target.tagName == "rect" || event.target.tagName == "text" || event.target.tagName == "g" || event.target.tagName == "svg") {

                    // 송신 컬럼명 클릭시 drag 가능하도록 수정
                    if (event.target.className.baseVal == "port-label" && event.target.getAttribute('x') == "226") {
                        elCheck = event.target.parentElement.children[0].children[2];
                        connectorId = elCheck.parentElement.getAttribute('id');
                        dragYN = true;
                        // 송신 테이블명 클릭시 drag 가능하도록 수정
                    } else if (event.target.className.baseVal == "port-title" && event.target.getAttribute('x') == "226") {
                        elCheck = event.target.parentElement.children[1].children[2];
                        tableconnectorId = elCheck.parentElement.getAttribute('id');
                        dragYN = true;
                    } else {
                        dragYN = false;
                        return true;
                    }
                } else {

                    // path 선택시 핸들링 가능하도록 설정
                    if (event.target.tagName == "path") {

                        if (event.target.className.baseVal == "tableconnector-path-outline" || event.target.className.baseVal == "tableconnector-path") {
                            // connector-handle.input-handle
                            elCheck = event.target.parentElement.children[2];
                            tableconnectorId = elCheck.parentElement.getAttribute('id');
                            outputCheck = true;

                        } else {
                            // connector-handle.input-handle
                            elCheck = event.target.parentElement.children[2];

                            connectorId = elCheck.parentElement.getAttribute('id');

                            outputCheck = true;

                        }
                    } else if (event.target.tagName == "circle") {

                        // port-scrim 선택시 핸들링 가능하도록 설정
                        if (event.target.className.baseVal == "port-scrim") {

                            // port 선택시 port의 마지막 connector로 element 포커스 설정
                            let connectors = event.target.getAttribute('connectors');

                            if (connectors !== null && connectors !== "") {

                                connectorId = connectors.split('|')[
                                    connectors.split('|').length - 1
                                ];

                                elCheck = document.getElementById(connectorId).children[2];

                            }
                        } else if (event.target.className.baseVal == "connector-handle output-handle" && event.target.getAttribute('data-drag').indexOf(":connector") > -1) {

                            // path 클릭후 input port 선택시 포커스 설정하기 위해서 위와 같은 조건 추가

                            elCheck = event.target.parentElement.children[2];
                            connectorId = elCheck.parentElement.getAttribute('id');

                        } else if (event.target.className.baseVal == "connector-handle input-handle") {

                            // input-handle 선택시 connector 생성되는 증상 막기위해 조건 추가

                            elCheck = event.target.parentElement.children[2];
                            connectorId = elCheck.parentElement.getAttribute('id');

                            // tableport-scrim 선택시 핸들링 가능하도록 설정
                        } else if (event.target.className.baseVal == "tableport-scrim") {
                            // tableport 선택시 tableport의 마지막 tableconnector로 element 포커스 설정
                            let connectors = event.target.getAttribute('tableconnectors');
                            if (connectors !== null && connectors !== "") {
                                tableconnectorId = connectors.split('|')[
                                    connectors.split('|').length - 1
                                ];
                                elCheck = document.getElementById(tableconnectorId).children[2];
                            }
                        } else if (event.target.className.baseVal == "tableconnector-handle tableoutput-handle" && event.target.getAttribute('data-drag').indexOf(":tableconnector") > -1) {
                            // path 클릭후 input port 선택시 포커스 설정하기 위해서 위와 같은 조건 추가
                            elCheck = event.target.parentElement.children[2];
                            tableconnectorId = elCheck.parentElement.getAttribute('id');
                        } else if (event.target.className.baseVal == "tableconnector-handle tableinput-handle") {
                            // input-handle 선택시 connector 생성되는 증상 막기위해 조건 추가
                            elCheck = event.target.parentElement.children[2];
                            tableconnectorId = elCheck.parentElement.getAttribute('id');
                        } else if (event.target.className.baseVal == "tableconnector-handle tableoutput-handle") {
                            tableconnectorId = event.target.parentElement.getAttribute('id');

                        } else {

                            connectorId = event.target.parentElement.getAttribute('id')

                        }
                    }

                    //drag 대상 유무 확인
                    dragYN = true;
                }

                // 선택된 connector element를 최하위로 이동시켜서 포커싱 시킴
                if (connectorId !== "") {
                    $('#' + connectorId).appendTo($('#connections-layer'));
                }

                // 선택된 tableconnector element를 최하위로 이동시켜서 포커싱 시킴
                if (tableconnectorId !== "") {
                    $('#' + tableconnectorId).appendTo($('#tableconnections-layer'));
                }

                let element = (elCheck == "") ? event.target : elCheck;
                // let element = event.target;
                let drag;

                //inputport 시작여부 판단 flag 초기화
                startInputPort = false;
                //inputport connector 존재 유무 판단 flag 초기화
                inputPortMapping = false;
                //inputport tableconnector 존재 유무 판단 flag 초기화
                inputTablePortMapping = false;

                while (!(drag = element.getAttribute("data-drag")) && element !== svg) {
                    element = element.parentNode;
                }

                drag = drag || "diagram:diagram";
                const split = drag.split(":");
                const id = split[0];
                var dragType = split[1];

                switch (dragType) {
                    case "diagram":
                        this.target = this;
                        break;

                    case "shape":
                        // shapeLookup : 모든 shape이 저장된 변수
                        this.target = shapeLookup[id];
                        break;

                    case "port":
                        // portLookup : 모든 port가 저장된 변수
                        const port = portLookup[id];

                        // port.isInput : port 시작점이 input에서 시작되는 확인할 수 있는 속성
                        if (port.isInput == true) {

                            // input port에 connector 존재 확인 변수
                            inputPortMapping = inputPortMappingCheck();

                            // 시작점이 input인지 확인 변수
                            startInputPort = true;

                        } else {

                            startInputPort = false;

                        }

                        // connector 생성
                        port.createConnector();
                        this.target = port.lastConnector;
                        this.dragType = this.target.dragType;

                        // path 선택시 output값 설정 필요
                        if (outputCheck == true) {
                            outportId = element.parentElement.lastElementChild.getAttribute('data-drag').split(':', 1)[0];
                        }
                        break;

                    case "connector":
                        this.target = connectorLookup[id];
                        break;

                    case "tableport":
                        // portLookup : 모든 port가 저장된 변수
                        const tableport = tableportLookup[id];
                        // port.isInput : port 시작점이 input에서 시작되는 확인할 수 있는 속성
                        if (tableport.isInput == true) {
                            // input port에 connector 존재 확인 변수
                            inputTablePortMapping = inputTablePortMappingCheck();
                            // 시작점이 input인지 확인 변수
                            startInputPort = true;
                        } else {
                            startInputPort = false;
                        }
                        // connector 생성
                        tableport.createConnector();
                        this.target = tableport.lastTableConnector;
                        this.dragType = this.target.dragType;
                        // path 선택시 output값 설정 필요
                        if (outputCheck == true) {
                            outportId = element.parentElement.lastElementChild.getAttribute('data-drag').split(':', 1)[0];
                        }
                        break;
                    case "tableconnector":
                        this.target = tableconnectorLookup[id];
                        break;
                }

                // input port에 connector 존재 유무 확인
                function inputPortMappingCheck() {
                    let allConnectorList = document.getElementsByClassName('connector');
                    let bMapping = false;
                    for (var checkHandle of allConnectorList) {
                        let inputPortHandle = checkHandle.children[2].getAttribute('data-drag');

                        if (inputPortHandle == drag) {
                            bMapping = true;
                            break;
                        } else {
                            bMapping = false;
                        }
                    }
                    return bMapping;
                }

                // input tableport에 tableconnector 존재 유무 확인
                function inputTablePortMappingCheck() {
                    let allConnectorList = document.getElementsByClassName('tableconnector');
                    let bMapping = false;
                    for (var checkHandle of allConnectorList) {
                        let inputPortHandle = checkHandle.children[2].getAttribute('data-drag');

                        if (inputPortHandle == drag) {
                            bMapping = true;
                            break;
                        } else {
                            bMapping = false;
                        }
                    }
                    return bMapping;
                }
            }

            // element drag 중일 때
            dragTarget() {
                //drag 대상 유무 확인
                if (dragYN == false) {
                    return true;
                }

                // 시작점이 input port이고 input port에 연결된 connector가 존재할때
                if (startInputPort == true && inputPortMapping == true) {

                    // this 객체에 input port가 존재하고 output port가 없을때
                    if (this.target.inputPort !== null && (this.target.outputPort == null || this.target.outputPort == undefined)) {

                        // input port id로 output port id 찾기
                        getOutputPortList(this.element, this.target.inputPort.id);

                        // 설정된 output port id가 ""일 경우
                        if (outportId == "") {
                            this.target.outputPort = {
                                id: outputPortList[outputPortList.length - 1]
                            };
                        } else {
                            // outportId가 존재할 경우 outputPortList에서 찾아서 this객체에 저장
                            for (let c = 0; c < outputPortList.length; c++) {
                                if (outportId == outputPortList[c]) {
                                    this.target.outputPort = {
                                        id: outputPortList[c]
                                    };
                                    outputPortList = [];
                                    break;
                                }
                            }
                        }
                    }

                    for (var saveThis of saveThisList) {
                        // outputport 여러개, intputport 한개 inputport 선택시 outputport 정보가 없으므로 inputport에
                        // mapping된 outputport값 구해서 배열의 마지막 값을 사용 마지막 값을 사용하는 이유 : 여러개의 connector 중에서
                        // 마직막에서 생성된 connector를 먼저 수정하도록 정의

                        if (this.target.hasOwnProperty("inputPort") && this.target.hasOwnProperty("outputPort")) {
                            if (this.target.inputPort.id == saveThis.inputPort.id && this.target.outputPort.id == saveThis.outputPort.id) {
                                if (document.getElementById(saveThis.id) !== null) {
                                    assignObject(this.target, saveThis);
                                } else {
                                    let index = saveThisList.indexOf(saveThis);

                                    if (index > -1) {
                                        saveThisList.splice(index, 1);
                                    }
                                    dragYN = false;
                                    return;
                                }
                            }
                        } else {
                            break;
                        }
                    }

                    rename(this.target, "update");

                    // dragTarget()함수가 연속해서 진행되기 때문에 rename함수를 반복 호출하여 rename함수에서 튕겨낼수 있도록 flag 설정
                    renameCheck = false;

                    // 시작점이 input tableport이고 input tableport에 연결된 tableconnector가 존재할때
                } else if (startInputPort == true && inputTablePortMapping == true) {

                    // this 객체에 input port가 존재하고 output port가 없을때
                    if (this.target.inputPort !== null && (this.target.outputPort == null || this.target.outputPort == undefined)) {

                        // input port id로 output port id 찾기
                        getOutputTablePortList(this.element, this.target.inputPort.id);

                        // 설정된 output port id가 ""일 경우
                        if (outportId == "") {
                            this.target.outputPort = {
                                id: outputTablePortList[outputTablePortList.length - 1]
                            };
                        } else {
                            // outportId가 존재할 경우 outputPortList에서 찾아서 this객체에 저장
                            for (let c = 0; c < outputTablePortList.length; c++) {
                                if (outportId == outputTablePortList[c]) {
                                    this.target.outputPort = {
                                        id: outputTablePortList[c]
                                    };
                                    outputTablePortList = [];
                                    break;
                                }
                            }
                        }
                    }
                    for (var saveThis of saveTableThisList) {
                        // outputport 여러개, intputport 한개 inputport 선택시 outputport 정보가 없으므로 inputport에
                        // mapping된 outputport값 구해서 배열의 마지막 값을 사용 마지막 값을 사용하는 이유 : 여러개의 connector 중에서
                        // 마직막에서 생성된 connector를 먼저 수정하도록 정의

                        if (this.target.hasOwnProperty("inputPort") && this.target.hasOwnProperty("outputPort")) {
                            if (this.target.inputPort.id == saveThis.inputPort.id && this.target.outputPort.id == saveThis.outputPort.id) {
                                if (document.getElementById(saveThis.id) !== null) {
                                    assignObject(this.target, saveThis);
                                } else {
                                    let index = saveTableThisList.indexOf(saveThis);

                                    if (index > -1) {
                                        saveTableThisList.splice(index, 1);
                                    }
                                    dragYN = false;
                                    return;
                                }
                            }
                        } else {
                            break;
                        }
                    }

                    // tableconnector의 연결이 끊어질 때
                    clearTableConnectors();

                    renameCheck = false;

                } else if (startInputPort == true && inputPortMapping == false) {
                    return true;
                }

                // scroll 하는 만큼 drag도 함께 움직이도록
                let scrollGap = 0;
                let scroll = document.getElementById("svgScroll").scrollTop;
                scrollGap = scroll - preScroll;
                preScroll = scroll;

                TweenLite.set(this.target.dragElement, {
                    x: `+=${this.draggable.deltaX}`,
                    y: `+=${this.draggable.deltaY + scrollGap}`
                });

                this.target.onDrag && this.target.onDrag();

                //객체로 속성 복사
                function assignObject(targetObject, copyObject) {
                    targetObject = Object.assign(targetObject, copyObject)
                }
            }
        }

        //
        // NODE SHAPE
        // ===========================================================================
        class NodeShape {

            constructor(element, x, y) {

                this.id = `shape_${++nextUidShape}`;
                this.dragType = "shape";

                element.setAttribute("data-drag", `${this.id}:shape`);

                this.element = element;
                this.dragElement = element;

                //TweenMax.min.js 제공 -> element x,y 좌표 설정
                TweenLite.set(element, { x, y });

                const inputElements = Array.prototype.slice.call(element.querySelectorAll(".input-field"));
                const outputElements = Array.prototype.slice.call(element.querySelectorAll(".output-field"));

                this.inputs = inputElements.map(element => {
                    const port = new NodePort(this, element, true);
                    portLookup[port.id] = port;
                    ports.push(port);
                    return port;
                });

                this.outputs = outputElements.map(element => {
                    const port = new NodePort(this, element, false);
                    portLookup[port.id] = port;
                    ports.push(port);
                    return port;
                });

                // tableport 생성
                const inputTableElements = Array.prototype.slice.call(element.querySelectorAll(".input-title"));
                const outputTableElements = Array.prototype.slice.call(element.querySelectorAll(".output-title"));

                this.inputTables = inputTableElements.map(element => {
                    const tableport = new NodeTablePort(this, element, true);
                    tableportLookup[tableport.id] = tableport;
                    tableports.push(tableport);
                    return tableport;
                });

                this.outputTables = outputTableElements.map(element => {
                    const tableport = new NodeTablePort(this, element, false);
                    tableportLookup[tableport.id] = tableport;
                    tableports.push(tableport);
                    return tableport;
                });

            }

            onDrag() {

                for (let input of this.inputs) {
                    input.update();
                }

                for (let output of this.outputs) {
                    output.update();
                }
            }
        }

        //
        // NODE TABLE PORT
        // ===========================================================================
        class NodeTablePort {

            constructor(parentNode, element, isInput) {

                this.id = `tableport_${++nextUidTablePort}`;
                this.dragType = "tableport";

                this.parentNode = parentNode;
                this.isInput = isInput;

                this.element = element;
                this.tableportElement = element.querySelector(".tableport");
                this.tableportScrim = element.querySelector(".tableport-scrim");

                this.tableportScrim.setAttribute("data-drag", `${this.id}:tableport`);

                //컬럼명 정보
                this.tableName = element.getElementsByClassName('tableport-scrim')[0].getAttribute('table');

                this.tableconnectors = [];
                this.lastTableConnector;

                //getBBox(); 함수는 SVGRect객체 리턴(위치정보, 너비, 높이)
                const bbox = this.tableportElement.getBBox();

                //createSVGPoint(); SVGPoint객체 반환
                this.global = svg.createSVGPoint();
                this.center = svg.createSVGPoint();
                this.center.x = bbox.x + bbox.width / 2;
                this.center.y = bbox.y + bbox.height / 2;

                this.update();

            }

            update() {

                //getTransformToElement() Transformation Matrix를 반환
                const transform = this.tableportElement.getTransformToElement(diagramElement);
                //matrixTransform() 2-D 평명에서 개체 또는 좌표계를 조작하는데 사용할 임의의 Affine 행렬 변형을 만듬
                this.global = this.center.matrixTransform(transform);

                for (let tableconnector of this.tableconnectors) {
                    tableconnector.updateHandle(this);
                }
            }

            createConnector() {

                let tableconnector;

                // tableconnectorPool은 삭제된 tableconnector 정보가 저정된 곳
                if (tableconnectorPool.length) {
                    // tableconnector 삭제 후 신규 생성시 마지막에 삭제한 tableconnector id로 설정
                    tableconnector = tableconnectorPool.pop();
                    tableconnectorLookup[tableconnector.id] = tableconnector;
                } else {
                    tableconnector = new TableConnector();
                }

                // tableconnector 생성에 필요한 this객체 속성값 초기 설정
                tableconnector.init(this);

                this.lastTableConnector = tableconnector;

                // output port에서 생성된 tableconnector일 경우 tableconnectors에 저장
                if (startInputPort == false) {
                    this.tableconnectors.push(tableconnector);
                }
            }

            // tableconnectors에서 connection 항목 삭제
            removeConnector(connection) {

                //중복되는 connection이 존재하기 때문에 connection id값으로 반복 조회해서 삭제
                const index = this.tableconnectors.indexOf(connection);

                if (index > -1) {
                    this.tableconnectors.splice(index, 1);
                }
            }

            // tableconnectors에 connection 추가
            addConnector(connection) {
                this.tableconnectors.push(connection);
                // 중복된 값 없도록 설정
                this.tableconnectors = _.uniqBy(this.tableconnectors, 'id');
            }
        }

        //
        // TABLE CONNECTOR
        // ===========================================================================
        class TableConnector {

            constructor() {
                this.id = `tableConnector_${++nextUidTableConnector}`;
                this.dragType = "tableconnector";
                this.isSelected = false;
                this.element = tableconnectorElement.cloneNode(true);
                this.path = this.element.querySelector(".tableconnector-path");
                this.pathOutline = this.element.querySelector(".tableconnector-path-outline");
                this.inputHandle = this.element.querySelector(".tableinput-handle");
                this.outputHandle = this.element.querySelector(".tableoutput-handle");

            }

            // connector 생성에 필요한 this객체 속성값 초기 설정
            init(port) {

                tableconnectorLayer.appendChild(this.element);

                this.isInput = port.isInput;

                if (port.isInput) {
                    this.inputPort = port;
                    this.dragElement = this.outputHandle;
                    this.staticElement = this.inputHandle;
                } else {
                    this.outputPort = port;
                    this.dragElement = this.inputHandle;
                    this.staticElement = this.outputHandle;
                }

                //tableconnector id 값 설정
                this.dragElement.parentElement.setAttribute('id', this.id);

                this.staticPort = port;
                this.dragElement.setAttribute("data-drag", `${this.id}:tableconnector`);
                this.staticElement.setAttribute("data-drag", `${port.id}:tableport:` + port.tableName);

                // this.inputHandle, this.outputHandle의 x,y 좌표 설정
                TweenLite.set([
                    this.inputHandle, this.outputHandle
                ], {
                    x: port.global.x,
                    y: port.global.y
                });
            }

            //Path position 설정
            updatePath() {

                const x1 = this.inputHandle._gsTransform.x;
                const y1 = this.inputHandle._gsTransform.y;

                const x4 = this.outputHandle._gsTransform.x;
                const y4 = this.outputHandle._gsTransform.y;

                const dx = Math.abs(x1 - x4) * bezierWeight;

                const p1x = x1;
                const p1y = y1;

                const p2x = x1 - dx;
                const p2y = y1;

                const p4x = x4;
                const p4y = y4;

                const p3x = x4 + dx;
                const p3y = y4;

                const data = `M${p1x} ${p1y} C ${p2x} ${p2y} ${p3x} ${p3y} ${p4x} ${p4y}`;

                this.path.setAttribute("d", data);
                this.pathOutline.setAttribute("d", data);
            }

            //Handle x, y 좌표 업데이트
            updateHandle(port) {

                if (port === this.inputPort) {

                    TweenLite.set(this.inputHandle, {
                        x: port.global.x,
                        y: port.global.y
                    });

                } else if (port === this.outputPort) {

                    TweenLite.set(this.outputHandle, {
                        x: port.global.x,
                        y: port.global.y
                    });
                }

                this.updatePath();
            }

            //drag 완료 후 진행
            placeHandle() {
                //drag 대상 유무 확인
                if (dragYN == false) {
                    return true;
                }

                tableconnectorClean();

                // dragTarget()함수가 연속해서 진행되기 때문에 rename함수를 반복 호출하여 rename함수에서 튕겨낼수 있도록 flag 설정
                renameCheck = true;

                const skipShape = this.staticPort.parentNode.element;

                let hitPort;

                for (let shape of shapes) {

                    // this객체에 shape shapes(전체 shape 저장변수)에 포함되어 있는지 확인
                    if (shape.element === skipShape) {
                        continue;
                    }

                    // this객체의 dragElement가 shapes(전체 shape 저장변수)의 element에 포함되어 있는지 확인
                    if (Draggable.hitTest(this.dragElement, shape.element)) {

                        // this.isInput(시작점이 input이면 true 아니면 false)
                        const ports = this.isInput ? shape.outputTables : shape.inputTables;

                        for (let port of ports) {

                            if (Draggable.hitTest(this.dragElement, port.tableportElement)) {
                                hitPort = port;
                                break;
                            }
                        }

                        if (hitPort) {
                            break;
                        }
                    }
                }

                if (hitPort) {

                    if (this.isInput) {
                        this.outputPort = hitPort;
                    } else {
                        this.inputPort = hitPort;
                    }

                    this.dragElement.setAttribute("data-drag", `${hitPort.id}:tableport:` + hitPort.tableName);

                    //동일한 connector가 존재할 경우 중복되지 않도록 설정
                    if (this.dragElement.getAttribute('class').indexOf("tableconnector-handle tableinput-handle") > -1 && document.getElementsByClassName('tableconnector-path-outline').length > 1) {
                        var allConnector = [].slice.call(document.getElementsByClassName('tableconnector'));

                        var currentConnector = allConnector.pop();

                        for (var value of allConnector) {
                            //output port 비교
                            if (value.children[3].getAttribute('data-drag').split(':')[0] ==
                                this.element.children[3].getAttribute('data-drag').split(':')[0]) {
                                //intput port 비교
                                if (value.children[2].getAttribute('data-drag').split(':')[0] ==
                                    this.element.children[2].getAttribute('data-drag').split(':')[0]) {
                                    {
                                        //모든 connector 중에서 중복되는게 없도록 첫번째 데이터를 제외하고 모두 삭제
                                        document.getElementById(this.id).remove();
                                    }
                                }
                            } else if (currentConnector.id == value.id) {
                                let idx = saveTableThisList.findIndex(function (item) {
                                    return item.id === currentConnector.id
                                });
                                if (idx > -1) {
                                    saveTableThisList.splice(idx, 1);
                                }
                            }
                        }
                    }

                    //tableconnector 목록에 추가 동일한 tableconnector 추가 안되도록 설정 필요
                    hitPort.addConnector(this);
                    this.updateHandle(hitPort);

                    let connectorId = this.id;
                    // 삭제된 tableconnector가 this로 설정되었을 경우 return 함
                    if (document.getElementById(connectorId) !== null) {
                        let idx = saveTableThisList.findIndex(function (item) {
                            return item.id == connectorId
                        });
                        if (idx > -1) {
                            saveTableThisList.splice(idx, 1, this);
                        } else {
                            saveTableThisList.push(this);
                        }
                    } else {
                        return true;
                    }
                    tablerename(this, "insert");
                    createAutoTableConnector(initDiagram);

                    // 내려놓는 tableconnector의 위치가 tableport가 아닐 때
                } else {
                    //connector 목록 중 합쳐진 데이터가 있을 경우 remove할때 columnName 속성, text에서 삭제 필요함
                    if ((this.hasOwnProperty('inputPort') && this.hasOwnProperty('outputPort')) && (this.inputPort !== null && this.outputPort !== null)) {
                        tablerename(this, "delete");
                    }
                    this.remove();
                }
            }

            // this 객체에 저정된 정보 삭제
            remove() {

                let connectorId = this.id;
                // 삭제된 connector가 this로 설정되었을 경우 return 함
                if (document.getElementById(connectorId) !== null) {
                    let idx = saveTableThisList.findIndex(function (item) {
                        return item.id == connectorId
                    });
                    if (idx > -1) {
                        saveTableThisList.splice(idx, 1);
                    } else {
                        saveTableThisList.push(this);
                    }
                }

                if (this.inputPort) {
                    this.inputPort.removeConnector(this);
                }

                if (this.outputPort) {
                    this.outputPort.removeConnector(this);
                }

                this.isSelected = false;

                this.path.removeAttribute("d");
                this.pathOutline.removeAttribute("d");
                if (this.dragElement !== undefined) {
                    this.dragElement.removeAttribute("data-drag");
                }
                if (this.staticElement !== undefined) {
                    this.staticElement.removeAttribute("data-drag");
                }

                this.staticPort = null;
                this.inputPort = null;
                this.outputPort = null;
                this.dragElement = null;
                this.staticElement = null;

                if (this.element.parentElement !== null && this.element.parentElement !== undefined) {
                    tableconnectorLayer.removeChild(this.element);
                    tableconnectorPool.push(this);
                }
            }

            onDrag() {
                this.updatePath();
            }

            onDragEnd() {
                this.placeHandle();
            }
        }

        //
        // NODE PORT
        // ===========================================================================
        class NodePort {

            constructor(parentNode, element, isInput) {

                this.id = `port_${++nextUidPort}`;
                this.dragType = "port";

                this.parentNode = parentNode;
                this.isInput = isInput;

                this.element = element;
                this.portElement = element.querySelector(".port");
                this.portScrim = element.querySelector(".port-scrim");

                this.portScrim.setAttribute("data-drag", `${this.id}:port`);

                //컬럼명 정보
                this.tableName = element.getElementsByClassName('port-scrim')[0].getAttribute('table');
                this.columnName = element.lastElementChild.innerHTML;
                this.initCol = element.lastElementChild.innerHTML;

                this.connectors = [];
                this.lastConnector;

                //getBBox(); 함수는 SVGRect객체 리턴(위치정보, 너비, 높이)
                const bbox = this.portElement.getBBox();

                //createSVGPoint(); SVGPoint객체 반환
                this.global = svg.createSVGPoint();
                this.center = svg.createSVGPoint();
                this.center.x = bbox.x + bbox.width / 2;
                this.center.y = bbox.y + bbox.height / 2;

                this.update();

            }

            update() {

                //getTransformToElement() Transformation Matrix를 반환
                const transform = this.portElement.getTransformToElement(diagramElement);
                //matrixTransform() 2-D 평명에서 개체 또는 좌표계를 조작하는데 사용할 임의의 Affine 행렬 변형을 만듬
                this.global = this.center.matrixTransform(transform);

                for (let connector of this.connectors) {
                    connector.updateHandle(this);
                }
            }

            createConnector() {

                let connector;

                // connectorPool은 삭제된 connector 정보가 저정된 곳
                if (connectorPool.length) {
                    // connector 삭제 후 신규 생성시 마지막에 삭제한 connector id로 설정
                    connector = connectorPool.pop();
                    connectorLookup[connector.id] = connector;
                } else {
                    connector = new Connector();
                }

                // connector 생성에 필요한 this객체 속성값 초기 설정
                connector.init(this);

                this.lastConnector = connector;

                // output port에서 생성된 connector일 경우 connectors에 저장
                if (startInputPort == false) {
                    this.connectors.push(connector);
                }
            }

            // connectors에서 connection 항목 삭제
            removeConnector(connection) {

                //중복되는 connection이 존재하기 때문에 connection id값으로 반복 조회해서 삭제
                const index = this.connectors.indexOf(connection);

                if (index > -1) {
                    this.connectors.splice(index, 1);
                }
            }

            // connectors에 connection 추가
            addConnector(connection) {
                this.connectors.push(connection);
                // 중복된 값 없도록 설정
                this.connectors = _.uniqBy(this.connectors, 'id');
            }
        }

        //
        // CONNECTOR
        // ===========================================================================
        class Connector {

            constructor() {
                this.id = `connector_${++nextUidConnector}`;
                this.dragType = "connector";
                this.isSelected = false;
                this.element = connectorElement.cloneNode(true);
                this.path = this.element.querySelector(".connector-path");
                this.pathOutline = this.element.querySelector(".connector-path-outline");
                this.inputHandle = this.element.querySelector(".input-handle");
                this.outputHandle = this.element.querySelector(".output-handle");

            }

            // connector 생성에 필요한 this객체 속성값 초기 설정
            init(port) {

                connectorLayer.appendChild(this.element);

                this.isInput = port.isInput;

                if (port.isInput) {
                    this.inputPort = port;
                    this.dragElement = this.outputHandle;
                    this.staticElement = this.inputHandle;
                } else {
                    this.outputPort = port;
                    this.dragElement = this.inputHandle;
                    this.staticElement = this.outputHandle;
                }

                //connector id 값 설정
                this.dragElement.parentElement.setAttribute('id', this.id);

                this.staticPort = port;
                this.dragElement.setAttribute("data-drag", `${this.id}:connector`);
                this.staticElement.setAttribute("data-drag", `${port.id}:port:` + port.tableName + '.' + port.columnName);

                // this.inputHandle, this.outputHandle의 x,y 좌표 설정
                TweenLite.set([
                    this.inputHandle, this.outputHandle
                ], {
                    x: port.global.x,
                    y: port.global.y
                });
            }

            //Path position 설정
            updatePath() {

                const x1 = this.inputHandle._gsTransform.x;
                const y1 = this.inputHandle._gsTransform.y;

                const x4 = this.outputHandle._gsTransform.x;
                const y4 = this.outputHandle._gsTransform.y;

                const dx = Math.abs(x1 - x4) * bezierWeight;

                const p1x = x1;
                const p1y = y1;

                const p2x = x1 - dx;
                const p2y = y1;

                const p4x = x4;
                const p4y = y4;

                const p3x = x4 + dx;
                const p3y = y4;

                const data = `M${p1x} ${p1y} C ${p2x} ${p2y} ${p3x} ${p3y} ${p4x} ${p4y}`;

                this.path.setAttribute("d", data);
                this.pathOutline.setAttribute("d", data);
            }

            //Handle x, y 좌표 업데이트
            updateHandle(port) {

                if (port === this.inputPort) {

                    TweenLite.set(this.inputHandle, {
                        x: port.global.x,
                        y: port.global.y
                    });

                } else if (port === this.outputPort) {

                    TweenLite.set(this.outputHandle, {
                        x: port.global.x,
                        y: port.global.y
                    });
                }

                this.updatePath();
            }

            //drag 완료 후 진행
            placeHandle() {
                //drag 대상 유무 확인
                if (dragYN == false) {
                    return true;
                }

                connectorClean();

                // dragTarget()함수가 연속해서 진행되기 때문에 rename함수를 반복 호출하여 rename함수에서 튕겨낼수 있도록 flag 설정
                renameCheck = true;

                const skipShape = this.staticPort.parentNode.element;

                let hitPort;

                for (let shape of shapes) {

                    // this객체에 shape shapes(전체 shape 저장변수)에 포함되어 있는지 확인
                    if (shape.element === skipShape) {
                        continue;
                    }

                    // this객체의 dragElement가 shapes(전체 shape 저장변수)의 element에 포함되어 있는지 확인
                    if (Draggable.hitTest(this.dragElement, shape.element)) {

                        // this.isInput(시작점이 input이면 true 아니면 false)
                        const ports = this.isInput ? shape.outputs : shape.inputs;

                        for (let port of ports) {

                            if (Draggable.hitTest(this.dragElement, port.portElement)) {
                                hitPort = port;
                                break;
                            }
                        }

                        if (hitPort) {
                            break;
                        }
                    }
                }

                if (hitPort) {

                    if (this.isInput) {
                        this.outputPort = hitPort;
                    } else {
                        this.inputPort = hitPort;
                    }

                    this.dragElement.setAttribute("data-drag", `${hitPort.id}:port:` + hitPort.tableName + '.' + hitPort.initCol);

                    //동일한 connector가 존재할 경우 중복되지 않도록 설정
                    if (this.dragElement.getAttribute('class').indexOf("connector-handle input-handle") > -1 && document.getElementsByClassName('connector-path-outline').length > 1) {
                        var allConnector = [].slice.call(document.getElementsByClassName('connector'));

                        var currentConnector = allConnector.pop();

                        for (var value of allConnector) {
                            //output port 비교
                            if (value.children[3].getAttribute('data-drag').split(':')[0] ==
                                this.element.children[3].getAttribute('data-drag').split(':')[0]) {
                                //intput port 비교
                                if (value.children[2].getAttribute('data-drag').split(':')[0] ==
                                    this.element.children[2].getAttribute('data-drag').split(':')[0]) {
                                    {
                                        // 모든 connector 중에서 중복되는게 없도록 첫번째 데이터를 제외하고 모두 삭제
                                        // document.getElementById(value.getAttribute('id')).remove();
                                        document.getElementById(this.id).remove();
                                    }
                                }
                            } else if (currentConnector.id == value.id) {
                                let idx = saveThisList.findIndex(function (item) {
                                    return item.id === currentConnector.id
                                });
                                if (idx > -1) {
                                    saveThisList.splice(idx, 1);
                                }
                            }
                        }
                    }

                    //connector 목록에 추가 동일한 connector 추가 안되도록 설정 필요
                    hitPort.addConnector(this);
                    this.updateHandle(hitPort);

                    let connectorId = this.id;
                    // 삭제된 connector가 this로 설정되었을 경우 return 함
                    if (document.getElementById(connectorId) !== null) {
                        let idx = saveThisList.findIndex(function (item) {
                            return item.id == connectorId
                        });
                        if (idx > -1) {
                            saveThisList.splice(idx, 1, this);
                        } else {
                            saveThisList.push(this);
                        }
                    } else {
                        return true;
                    }

                    rename(this, "insert");

                } else {
                    //connector 목록 중 합쳐진 데이터가 있을 경우 remove할때 columnName 속성, text에서 삭제 필요함
                    if ((this.hasOwnProperty('inputPort') && this.hasOwnProperty('outputPort')) && (this.inputPort !== null && this.outputPort !== null)) {
                        rename(this, "delete");
                    }
                    this.remove();
                }
            }

            // this 객체에 저정된 정보 삭제
            remove() {

                let connectorId = this.id;
                // 삭제된 connector가 this로 설정되었을 경우 return 함
                if (document.getElementById(connectorId) !== null) {
                    let idx = saveThisList.findIndex(function (item) {
                        return item.id == connectorId
                    });
                    if (idx > -1) {
                        saveThisList.splice(idx, 1);
                    } else {
                        saveThisList.push(this);
                    }
                }

                if (this.inputPort) {
                    this.inputPort.removeConnector(this);
                }

                if (this.outputPort) {
                    this.outputPort.removeConnector(this);
                }

                this.isSelected = false;

                this.path.removeAttribute("d");
                this.pathOutline.removeAttribute("d");
                if (this.dragElement !== undefined) {
                    this.dragElement.removeAttribute("data-drag");
                }
                if (this.staticElement !== undefined) {
                    this.staticElement.removeAttribute("data-drag");
                }

                this.staticPort = null;
                this.inputPort = null;
                this.outputPort = null;
                this.dragElement = null;
                this.staticElement = null;

                if (this.element.parentElement !== null && this.element.parentElement !== undefined) {
                    connectorLayer.removeChild(this.element);
                    connectorPool.push(this);
                }
            }

            onDrag() {
                this.updatePath();
            }

            onDragEnd() {
                this.placeHandle();
            }
        }

        // 자동으로 connector 생성 함수
        function createAutoConnector(data, clearCheck) {
            autoCon = true;
            //기본 connector 생성 송신데이터 기준 컬럼 갯수
            let outputs = document.getElementsByClassName('outputs')[0].getElementsByClassName('output-field').length;

            //수신데이터 기준 컬럼 갯수
            let inputs = document.getElementsByClassName('inputs')[0].getElementsByClassName('input-field').length;
            let el = document.querySelector("#diagram");
            let port = document.getElementsByClassName('port-scrim');

            // 인터페이스 상세 조회시 송,수신 맵핑정보 유무 확인
            if (mappingData.length > 0 && clearCheck == false) {

                for (let a = 0; a < mappingData.length; a++) {

                    let outMatch = -1;
                    let inMatch = -1;

                    let findInputData = mappingData[a].split(',')[0]; // 수신데이터 정보(테이블명:컬럼명)
                    let findOutputDataList = mappingData[a].split(',')[1]; //송신데이터 정보(테이블명:컬럼명|테이블명:컬럼명|...)
                    let findOutputDataLen = findOutputDataList.split('|').length; //송신데이터 정보 길이

                    var commonDataCheck = false;
                    
                    let inData = "";
                    let inTable = "";
                    let inColumn = "";
                    
                    for (let b = 0; b < findOutputDataLen; b++) {

                        let findOutputData = "";

                        // 길이가 1이면 findOutputData는 findOutputDataList와 동일 길이가 1보다 크면
                        // findOutputDataList.split('|')[b];하여 잘라서 사용
                        if (findOutputDataLen == 1) {
                            findOutputData = findOutputDataList;
                        } else if (findOutputDataLen > 1) {
                            findOutputData = findOutputDataList.split('|')[b];
                        } else {
                            continue;
                        }
                        
                        // 공통데이터 존재여부 확인
                        if (findOutputData.indexOf('\"') > -1){
                        	commonDataCheck = true;
                        }

                        let outData = findOutputData.split('.');
                        let outTable = outData[0];
                        let outColumn = outData[1];

                        // mapping 정보에 해당하는 output을 조회
                        let selectOutput = $(".outputs:first .port .port-scrim[table=" + outTable + "][initCol=" + outColumn + "]")[0];
                        if (selectOutput !== undefined) {
                            let outPos = selectOutput.getAttribute('data-drag').split(':')[0].split('_')[1] - 1;
                            if (outPos > -1) {
                                outMatch = outPos;
                            }
                        }

                        inData = findInputData.split('.');
                        inTable = inData[0];
                        inColumn = inData[1];
                        
                        // mapping 정보에 해당하는 input을 조회
                        let selectInput = $(".inputs:first .port .port-scrim[table=" + inTable + "][initCol=" + inColumn + "]")[0];
                        if (selectInput !== undefined) {
                            let inPos = selectInput.getAttribute('data-drag').split(':')[0].split('_')[1] - 1;
                            if (inPos > -1) {
                                inMatch = inPos;
                            }
                        }

                        // output, input port 위치 값이 -1보다 크면 connector 생성
                        if (outMatch > -1 && inMatch > -1) {
                            // output 시작점
                            data.target = port[outMatch];
                            // 시작점 설정
                            data.prepareTarget(data);

                            // input 끝점 위치 찾기
                            let pos = document.getElementsByClassName('port-scrim')[inMatch].getTransformToElement(el);
                            // 끝점 위치 설정
                            data.target.inputHandle.setAttribute('transform', 'matrix(1,0,0,1,' + (parseInt(pos.e) + 15) + ',' + (parseInt(pos.f) + 10) + ')');
                            // connector 그리기
                            data.stopDragging(data);
                        }
                    }
                    if (commonDataCheck){
	                    $(".inputs:first .port .port-scrim[table=" + inTable + "][initCol=" + inColumn + "]")[0].setAttribute('columnName', findOutputDataList);
	                    $(".inputs:first .port .port-scrim[table=" + inTable + "][initCol=" + inColumn + "]")[0].parentElement.parentElement.lastChild.innerHTML = textReduce(findOutputDataList);
                    }
                }

            } else {

                // output 기준으로 connector 자동 생성
                for (let n = 0; n < outputs; n++) {
                    data.target = document.getElementsByClassName('port-scrim')[n];

                    //output table, columnName
                    let outputTable = data.target.getAttribute('table');
                    let outputColName = data.target.getAttribute('columnName');

                    let matchTable = $(".inputs .input-field .port .port-scrim[table=" + outputTable + "]").length;
                    // 동일 테이블명이 1개 이상 있는지 유무 확인
                    if (matchTable > 0) {
                        // 동일 테이블명, 동일 컬럼명이 존재하는지 확인
                        let matchCol = "";

                        if (clearCheck == false) {
                            matchCol = $(".inputs .input-field .port .port-scrim[table=" + outputTable + "][columnName=" + outputColName + "]");
                        } else {
                            matchCol = $(".inputs .input-field .port .port-scrim[table=" + outputTable + "][initCol=" + outputColName + "]");
                        }

                        if (matchCol[0] !== undefined) {
                            // connector 시작점 설정
                            data.prepareTarget(data);
                            let matchPos = matchCol.attr('data-drag').split(':')[0].split('_')[1] - 1;
                            let pos = document.getElementsByClassName('port-scrim')[matchPos].getTransformToElement(el);
                            data.target.inputHandle.setAttribute('transform', 'matrix(1,0,0,1,' + (parseInt(pos.e) + 15) + ',' + (parseInt(pos.f) + 10) + ')');
                            data.stopDragging(data);
                        }
                    }
                }
            }
        }

        // tableconnector를 기준으로 자동으로 connector 생성 함수
        function createAutoTableConnector(data) {
            //송신데이터 기준 컬럼 갯수
            let outputs = document.getElementsByClassName('outputs')[0].getElementsByClassName('output-field').length;
            let tconLength = document.getElementsByClassName('tableconnector').length;
            let inputTable = document.getElementsByClassName('tableconnector')[tconLength - 1].children[2].getAttribute('data-drag').split(':')[2];
            let outputTable = document.getElementsByClassName('tableconnector')[tconLength - 1].children[3].getAttribute('data-drag').split(':')[2];
            let el = document.querySelector("#diagram");

            // output 기준으로 connector 자동 생성
            for (let n = 0; n < outputs; n++) {
                if (outputTable == document.getElementsByClassName('port-scrim')[n].getAttribute('table')) {
                    data.target = document.getElementsByClassName('port-scrim')[n];

                    //output columnName
                    let outputColName = data.target.getAttribute('columnName');

                    // 동일 컬럼명이 존재하는지 확인
                    let matchCol = "";

                    matchCol = $(".inputs .input-field .port .port-scrim[table=" + inputTable + "][initCol=" + outputColName + "]");

                    if (matchCol[0] !== undefined) {
                        // connector 시작점 설정
                        data.prepareTarget(data);
                        let matchPos = matchCol.attr('data-drag').split(':')[0].split('_')[1] - 1;
                        let pos = document.getElementsByClassName('port-scrim')[matchPos].getTransformToElement(el);
                        data.target.inputHandle.setAttribute('transform', 'matrix(1,0,0,1,' + (parseInt(pos.e) + 15) + ',' + (parseInt(pos.f) + 10) + ')');
                        data.stopDragging(data);
                    }
                }
            }
        }

        // connector 초기화 함수
        function clearData() {

            //변수 초기화
            renameCheck = true;
            outportId = "";
            autoCon = false;
            dragYN = true;
            inputPortMapping = false;
            saveThisList = [];
            startInputPort = false;
            outputPortList = [];
            nextUidConnector = 0;
            connectorLookup = {};
            connectorPool = [];

            nextUidTableConnector = 0;
            saveTableThisList = [];
            inputTablePortMapping = false;
            outputTablePortList = [];
            tableconnectorLookup = {};
            tableconnectorPool = [];

            // 모든 connector 삭제
            let cons = document.getElementById('connections-layer');
            while (cons.hasChildNodes()) {
                cons.removeChild(cons.firstChild);
            }

            // input port connector 속성 삭제
            let inputPort = $('.inputs .input-field .port .port-scrim');

            for (let inputPos = 0; inputPos < inputPort.length; inputPos++) {
                inputPort[inputPos].setAttribute("connectors", "");

                let initColName = inputPort[inputPos].getAttribute("initCol");
                inputPort[inputPos].setAttribute("columnName", initColName);
                inputPort[inputPos].parentElement.nextElementSibling.innerHTML = initColName;
            }

            nextUidConnector = 0;

            // 모든 tableconnector 삭제
            let tcons = document.getElementById('tableconnections-layer');
            while (tcons.hasChildNodes()) {
                tcons.removeChild(tcons.firstChild);
            }
            // input port tableconnector 속성 삭제
            let inputTablePort = $('.inputs .input-title .tableport .tableport-scrim');
            for (let inputPos = 0; inputPos < inputTablePort.length; inputPos++) {
                inputTablePort[inputPos].setAttribute("tableconnectors", "");
            }
            nextUidTableConnector = 0;

            createAutoConnector(initDiagram, true);
        }


        // 연결된 connector가 아닌 connector를 찾아서 삭제
        function connectorClean() {
            let connectors = document.getElementsByClassName('connector');
            if (connectors.length > 0) {
                for (var checkConnector of connectors) {
                    let inputPortCheck = checkConnector.children[2].getAttribute('transform');
                    let outputPortCheck = checkConnector.children[3].getAttribute('transform');

                    let inX = parseInt(inputPortCheck.split(',')[4]);
                    let inY = parseInt(inputPortCheck.split(',')[5].split(')')[0]);

                    let outX = parseInt(outputPortCheck.split(',')[4]);
                    let outY = parseInt(outputPortCheck.split(',')[5].split(')')[0]);

                    let checkX = Math.abs(inX - outX);
                    let checkY = Math.abs(inY - outY);

                    if (inputPortCheck !== null && outputPortCheck !== null) {
                        // if(inputPortCheck == outputPortCheck && checkEct1 == null && checkEct2 ==
                        // null) {
                        if (checkX < 10 && checkY < 10) {
                            checkConnector.remove();
                        }
                    }
                }
            }
        }

        // 연결된 tableconnector가 아닌 tableconnector를 찾아서 삭제
        function tableconnectorClean() {
            let tableconnectors = document.getElementsByClassName('tableconnector');
            if (tableconnectors.length > 0) {
                for (var checkConnector of tableconnectors) {
                    let inputPortCheck = checkConnector.children[2].getAttribute('transform');
                    let outputPortCheck = checkConnector.children[3].getAttribute('transform');

                    let inX = parseInt(inputPortCheck.split(',')[4]);
                    let inY = parseInt(inputPortCheck.split(',')[5].split(')')[0]);

                    let outX = parseInt(outputPortCheck.split(',')[4]);
                    let outY = parseInt(outputPortCheck.split(',')[5].split(')')[0]);

                    let checkX = Math.abs(inX - outX);
                    let checkY = Math.abs(inY - outY);

                    if (inputPortCheck !== null && outputPortCheck !== null) {
                        if (checkX < 10 && checkY < 10) {
                            checkConnector.remove();
                        }
                    }
                }
            }
        }


        // bsh
        // 컬럼명 텍스트를 줄이는 함수
        function textReduce(textData) {
            // 텍스트 줄여서 보여질 변수
            let moreData = "...";
            var tmpData = '';

            if (textData.length < 100) {
                tmpData = textData;
            } else {
                // 자른 tmp를 마지막 | 기준으로 뒤에 줄임말을 붙여줌
                tmpData = textData.substring(0, textData.substring(0, 100).lastIndexOf('|')) + ('|' + moreData);
            }

            var columns = tmpData.split('|');
            var tmp = '';
            for (var i = 0; i < columns.length; i++) {
                if (columns[i].indexOf('\"') > -1) {
                    tmp += columns[i] + '<tspan style="fill:red">|</tspan>';
                } else if (columns[i].indexOf(moreData) > -1) {
                    tmp += moreData;
                } else {
                    var tableName = columns[i].split('.')[0];
                    var columnName = columns[i].split('.')[1];
                    columnName = '.<tspan style="fill:blue">' + columnName + '</tspan>';
                    tmp += tableName + columnName + '<tspan style="fill:red">|</tspan>';
                }
            }

            if (textData.length < 100) {
                tmp = tmp.substring(0, tmp.lastIndexOf('|'));
            } else {
                tmp = tmp.substring(0, tmp.lastIndexOf('|')) + ('|<tspan style="fill:black">' + moreData + '</tspan>');
            }

            return tmp;
        }

        // 컬럼명 설정 함수
        function rename(currentEl, type) {

            // 화면에 뿌려줄 컬럼명 데이터
            let tmpData = ""; // bsh

            // rename 함수 호출 위치(dragTarget(), placeHandle()) dragTarget()함수에서 연속적인 호출이 발생하기
            // 때문에 renameCheck 변수를 flag로 설정해서 튕겨낼수 있도록 설정
            if (renameCheck == false)
                return true;

            ////// connectors 속성 수정 -시작
            let connectData = $("[data-drag=" + currentEl.inputPort.id + "\\:port]").attr("connectors");

            // connector 속성 유무 확인
            if (connectData !== undefined) {
                // connectors 속성값 (중복 제거, 빈값 추가) 중복 제거
                if (connectData.indexOf('|' + currentEl.id) > -1 || connectData.indexOf(currentEl.id + '|') > -1) {
                    connectData = connectData.replace('|' + currentEl.id, "");
                    connectData = connectData.replace(currentEl.id + '|', "");

                    if (type == "change") {
                        connectData += ('|' + currentEl.id);
                    }
                } else {
                    // type이 delete, update일 경우
                    if (type == "delete" || type == "update") {
                        connectData = connectData.replace(currentEl.id, "");
                    } else {
                        // type이 insert 빈값 추가
                        if (type !== "change") {
                            if (connectData == "") {
                                connectData = currentEl.id;
                            } else if ($('#' + currentEl.id)[0] !== undefined) {
                                connectData += ('|' + currentEl.id);
                            }
                        }
                    }
                }
            } else {
                // 최초 connector 생성시 초기값 설정
                connectData = currentEl.id
            }

            $("[data-drag=" + currentEl.inputPort.id + "\\:port]").attr("connectors", connectData);
            ////// connectors 속성 수정 -끝  inputport label 수정 -시작
            let textData = $("[data-drag=" + currentEl.inputPort.id + "\\:port]").parents().children(".port-scrim")[0].getAttribute('columnName'); // bsh
            // 화면에 보여지는 컬럼명
            // let tmpData = $("[data-drag=" + currentEl.inputPort.id + "\\:port]").parents().children(".port-label")[0].innerHTML; //bsh
            if (textData.indexOf('.') < 0) {
                textData = currentEl.inputPort.tableName + '.' + textData;
            }

            let checkData = "";

            checkData = $("[data-drag=" + currentEl.outputPort.id + "\\:port]").attr('table') + '.' + $("[data-drag=" + currentEl.outputPort.id + "\\:port]").attr('initCol');

            // 컬럼명이 다를 경우 label (중복 제거, 빈값 추가) 중복 제거
            if (textData.indexOf('|' + checkData) > -1 || textData.indexOf(checkData + '|') > -1) {
                textData = textData.replace('|' + checkData, "");
                textData = textData.replace(checkData + '|', "");


                if (type == "change") {
                    textData += ('|' + checkData);
                }
            } else {

                if (connectData.split('|').length == 1) {
                    // connector가 1개 또는 없을때
                    if (type == "delete") {
                        textData = textData.replace(checkData, "");

                        if (textData == "") {
                            textData = currentEl.inputPort.portScrim.getAttribute('initCol');
                        }
                    } else {
                        textData = checkData;

                    }
                } else {
                    // connector가 여러개 있을때
                    if (type == "delete" || type == "update") {
                        textData = textData.replace(checkData, "");

                    } else {
                        textData += ('|' + checkData);

                    }
                }
            }
            tmpData = textReduce(textData); // bsh

            // connectors 속성이 정의되어 있지 않거나 없으면 초기값으로 설정
            if (connectData == undefined || connectData == "") {
                tmpData = textData = currentEl.inputPort.portScrim.getAttribute('initCol'); //bsh
            }
            $("[data-drag=" + currentEl.inputPort.id + "\\:port]").parents().children(".port-label")[0].innerHTML = tmpData; // bsh
            $("[data-drag=" + currentEl.inputPort.id + "\\:port]").attr("columnName", textData);
            shapes[1].inputs[parseInt(currentEl.inputPort.id.substr(5)) - document.getElementsByClassName('outputs')[0].getElementsByClassName('output-field').length - 1].columnName = textData;
            ////// inputport label 수정 -끝
        }

        function tablerename(currentEl, type) {
            // rename 함수 호출 위치(dragTarget(), placeHandle()) dragTarget()함수에서 연속적인 호출이 발생하기
            // 때문에 renameCheck 변수를 flag로 설정해서 튕겨낼수 있도록 설정
            if (renameCheck == false)
                return true;

            ////// tableconnectors 속성 수정 -시작
            let connectData = $("[data-drag=" + currentEl.inputPort.id + "\\:tableport]").attr("tableconnectors");
            // tableconnector 속성 유무 확인
            if (connectData !== undefined) {
                // tableconnectors 속성값 (중복 제거, 빈값 추가) 중복 제거
                if (connectData.indexOf('|' + currentEl.id) > -1 || connectData.indexOf(currentEl.id + '|') > -1) {
                    connectData = connectData.replace('|' + currentEl.id, "");
                    connectData = connectData.replace(currentEl.id + '|', "");
                    if (type == "change") {
                        connectData += ('|' + currentEl.id);
                    }
                } else {
                    // type이 delete, update일 경우
                    if (type == "delete" || type == "update") {
                        connectData = connectData.replace(currentEl.id, "");
                    } else {
                        // type이 insert 빈값 추가
                        if (type !== "change") {
                            if (connectData == "") {
                                connectData = currentEl.id;
                            } else if ($('#' + currentEl.id)[0] !== undefined) {
                                connectData += ('|' + currentEl.id);
                            }
                        }
                    }
                }
            } else {
                // 최초 tableconnector 생성시 초기값 설정
                connectData = currentEl.id
            }
            $("[data-drag=" + currentEl.inputPort.id + "\\:tableport]").attr(
                "tableconnectors",
                connectData
            );
            ////// tableconnectors 속성 수정 -끝
        }

        // tableconnector 연결을 끊을 때 connector 초기화
        function clearTableConnectors() {
            let cons = document.getElementById('connections-layer');
            let conLength = document.getElementsByClassName('connector').length;
            let tconLength = document.getElementsByClassName('tableconnector').length;
            let outputTable = document.getElementsByClassName('tableconnector')[tconLength - 2].children[3].getAttribute('data-drag').split(':')[2];
            let inputTable = document.getElementsByClassName('tableconnector')[tconLength - 2].children[2].getAttribute('data-drag').split(':')[2];
            let pos = 0;
            for (let n = 0; n < conLength; n++) {
                let connector = saveThisList[pos];
                if ((outputTable == connector.element.children[3].getAttribute('data-drag').split(':')[2].split('.')[0]) && (inputTable == connector.element.children[2].getAttribute('data-drag').split(':')[2].split('.')[0])) {
                    rename(connector, "delete");
                    connector.remove();
                } else {
                    pos++;
                }
            }
            for (let n = 0; n < tconLength - 1; n++) {
                let tableconnector = saveTableThisList[n];
                if ((outputTable == tableconnector.element.children[3].getAttribute('data-drag').split(':')[2]) && (inputTable == tableconnector.element.children[2].getAttribute('data-drag').split(':')[2])) {
                    tablerename(tableconnector, "delete");
                }
            }
        }


        //inputport id값으로 outputport 정보
        function getOutputPortList(currentElement, inputPortId) {

            if (outputPortList.length > 0) {
                outputPortList = [];
            }

            let connectors = currentElement.getElementsByClassName('connector');
            for (let connector of connectors) {
                if (connector.getElementsByClassName('input-handle')[0].getAttribute('data-drag').split(':')[0] == inputPortId) {
                    let outputPortId = connector.getElementsByClassName('output-handle')[0].getAttribute('data-drag').split(':')[0];
                    if (outputPortId.indexOf('port') > -1) {
                        outputPortList.push(outputPortId);
                    }
                }
            }
        }

        //inputport id값으로 outputport 정보 리스트 추출 함수
        function getOutputTablePortList(currentElement, inputPortId) {

            if (outputTablePortList.length > 0) {
                outputTablePortList = [];
            }

            let connectors = currentElement.getElementsByClassName('tableconnector');
            for (let connector of connectors) {
                if (connector.getElementsByClassName('tableinput-handle')[0].getAttribute('data-drag').split(':')[0] == inputPortId) {
                    let outputPortId = connector.getElementsByClassName('tableoutput-handle')[0].getAttribute('data-drag').split(':')[0];
                    if (outputPortId.indexOf('tableport') > -1) {
                        outputTablePortList.push(outputPortId);
                    }
                }
            }
        }

        // 송신, 수신, mapping 정보를 MappingConfig.xml에 저장하는 서비스
        function sendServer(objectData) {
            $.ajax({
                url: 'interface/mappingSave',
                type: 'post',
                data: objectData,
                async: false,
                success: successCall,
                error: errorCall
            });

            function successCall(s) {
                console.log("SendSuccess");
                console.log(s);
                alert("SendSuccess");
            }

            function errorCall(e) {
                console.log("SendError");
                console.log(e);
                alert("SendError");
            }
        }

        function saveData() {

            // 송/수신 데이터 샘플 
            // var resultData = '{"send":{"sendColumns":[["USER_NO","USER_ID","USER_NAME","USER_POSITION","USER_DEPT","USER_TELEPHONE","USER_MAIL","USER_PHONE","USER_ADDRESS","CHG_DTTM","TRN_ID","MSG_ID","TRN_STATS","TRN_DT","TRN_MSG"]],"sendAdapterServiceId":"DB.IFSender.IF_K4M_KR_D001","tableNames":["IF_TB_USERS"]},"receive":{"sendTableNames":["IF_TB_USERS"],"receiveColumns":[["USER_NO","USER_ID","USER_NAME","USER_POSITION","USER_DEPT","USER_TELEPHONE","USER_MAIL","USER_PHONE","USER_ADDRESS","CHG_DTTM","TRN_ID","MSG_ID","TRN_STATS","TRN_DT","TRN_MSG","SEQ"]],"tableNames":["IF_TB_USERS"],"receiveAdapterServiceId":"DB.IFReceiver.IF_K4M_KR_D001"},"mappingData":["IF_TB_USERS.USER_NO,IF_TB_USERS.USER_NO|IF_TB_USERS.USER_ID|\"123\"|IF_TB_USERS.USER_NAME|IF_TB_USERS.USER_POSITION","IF_TB_USERS.USER_ID,\"test\"","IF_TB_USERS.USER_POSITION,IF_TB_USERS.USER_POSITION","IF_TB_USERS.USER_DEPT,IF_TB_USERS.USER_DEPT","IF_TB_USERS.USER_TELEPHONE,IF_TB_USERS.USER_TELEPHONE","IF_TB_USERS.USER_MAIL,IF_TB_USERS.USER_MAIL","IF_TB_USERS.USER_PHONE,IF_TB_USERS.USER_PHONE","IF_TB_USERS.USER_ADDRESS,IF_TB_USERS.USER_ADDRESS","IF_TB_USERS.CHG_DTTM,IF_TB_USERS.CHG_DTTM","IF_TB_USERS.TRN_ID,IF_TB_USERS.TRN_ID","IF_TB_USERS.MSG_ID,IF_TB_USERS.MSG_ID","IF_TB_USERS.TRN_STATS,IF_TB_USERS.TRN_STATS","IF_TB_USERS.TRN_DT,IF_TB_USERS.TRN_DT","IF_TB_USERS.TRN_MSG,IF_TB_USERS.TRN_MSG"]}'

            var resultData = new Object();

            let tempColumnList = new Array();
            let tempColumn = "";
            let tempTable = new Array();

            //송신부 데이터 생성
            let sendElement = document.getElementsByClassName('outputs');

            resultData.sendAdapterServiceId = document.getElementsByClassName('header-title')[0].innerHTML;

            // 좌측에 있는 송신 원본 테이블 기준으로 송신(테이블, 컬럼) 전송
            for (let i = 0; i < sendElement[0].children.length; i++) {
                let className = sendElement[0].children[i].getAttribute('class');
                if (className == 'output-title') {

                    if (className == 'output-title') {
                        tempTable.push(sendElement[0].children[i].firstElementChild.innerHTML);
                    }

                    if (tempColumn !== "") {
                        tempColumnList.push(tempColumn);
                        if (tempColumnList.length > 0) {
                            tempColumn = "";
                        }
                    }
                } else {
                    if (tempColumn == "") {
                        tempColumn = sendElement[0].children[i].lastElementChild.innerHTML;
                    } else {
                        tempColumn += (',' + sendElement[0].children[i].lastElementChild.innerHTML);
                    }

                    if (i == (sendElement[0].children.length - 1)) {
                        tempColumnList.push(tempColumn);
                    }
                }
            }

            resultData.sendTableNames = tempTable;
            resultData.sendColumns = tempColumnList;

            tempColumnList = [];
            tempColumn = "";
            tempTable = [];

            //수신부 데이터 생성
            let receiveElement = document.getElementsByClassName('outputs')[1];

            resultData.receiveAdapterServiceId = document.getElementsByClassName('header-title')[1].innerHTML;

            for (let i = 0; i < receiveElement.children.length; i++) {

                let className = receiveElement.children[i].getAttribute('class');
                if (className == 'output-title') {

                    tempTable.push(receiveElement.children[i].firstElementChild.innerHTML);

                    if (tempColumn !== "") {
                        tempColumnList.push(tempColumn);
                        if (tempColumnList.length > 0) {
                            tempColumn = "";
                        }
                    }
                } else {
                    if (tempColumn == "") {
                        tempColumn = receiveElement.children[i].lastElementChild.innerHTML;
                    } else {
                        tempColumn += (',' + receiveElement.children[i].lastElementChild.innerHTML);
                    }

                    if (i == (receiveElement.children.length - 1)) {
                        tempColumnList.push(tempColumn);
                    }
                }
            }

            resultData.receiveTableNames = tempTable;
            resultData.receiveColumns = tempColumnList;

            resultData.receiveSendTableNames = sendTableNames;

            tempColumnList = [];
            tempColumn = "";
            tempTable = [];

            //connector 데이터 생성
            let tempConnector = new Array();

            //connector속성의 값을 가지고 있는 inputPort 추출
//             let inputPort = $('.input-field .port .port-scrim[connectors^=connector]');
//             for (let inputPos = 0; inputPos < inputPort.length; inputPos++) {
//                 let temp = inputPort[inputPos].getAttribute('table') + '.' + inputPort[inputPos].getAttribute('initCol') + ',' + inputPort[inputPos].getAttribute('columnName');
//                 tempConnector.push(temp);
//             }

			// 모든 inputPort를 추출해서 연결된 connector가 있거나 공통데이터가 입력되어있다면 MappingConfig.xml에 저장 
            let inputPort = $('.input-field .port .port-scrim');
            for (let inputPos = 0; inputPos < inputPort.length; inputPos++) {
            	if (inputPort[inputPos].getAttribute('initCol') == inputPort[inputPos].getAttribute('columnName')) {
            		continue;
            	}
                let temp = inputPort[inputPos].getAttribute('table') + '.' + inputPort[inputPos].getAttribute('initCol') + ',' + inputPort[inputPos].getAttribute('columnName');
                tempConnector.push(temp);
            }
			
            resultData.mappingConnection = tempConnector;

            resultData.interfaceId = interfaceId;

            sendServer(resultData);
        }

        function viewModal(column) {
            nowClickColumn = column;
            var columnList = nowClickColumn.parentElement.firstElementChild.lastElementChild.getAttribute('columnName');
            var conList = nowClickColumn.parentElement.firstElementChild.lastElementChild.getAttribute('connectors');
            var zIndex = 9999;
            var modal = document.getElementById('my_modal');
            var btnModal = document.getElementById('btn_modal');

            // 모달 div 뒤에 희끄무레한 레이어
            var bg = document.createElement('div');
            bg.setStyle({
                position: 'fixed',
                zIndex: zIndex,
                left: '0px',
                top: '0px',
                width: '100%',
                height: '100%',
                overflow: 'auto',
                // 레이어 색갈은 여기서 바꾸면 됨
                backgroundColor: 'rgba(0,0,0,0.4)'
            });
            document.body.append(bg);

            var tcolumns = columnList.split('|');
            var tconnectors = [];
            var divAll = document.createElement("div");
            divAll.setAttribute('style', 'flex: 1');
            var conCount = 0;
            for (var i = 1; i <= tcolumns.length; i++) {

                if (!(conList == null || conList == '')) {
                    tconnectors = conList.split('|');
                } else if (column.parentElement.firstElementChild.lastElementChild.getAttribute('initCol') == column.parentElement.firstElementChild.lastElementChild.getAttribute('columnName')) {
                    // 연결된 connector가 없고 입력된 공통데이터도 없을 때
                    break;
                }

                var div = document.createElement("div");

                // 위쪽 버튼
                var upbtn = document.createElement("button");
                upbtn.innerHTML = 'UP';
                upbtn.setAttribute('onclick', 'columnUp(this)');
                upbtn.setAttribute('style', 'margin:1%;');

                // 아래쪽 버튼
                var downbtn = document.createElement("button");
                downbtn.innerHTML = 'DOWN';
                downbtn.setAttribute('onclick', 'columnDown(this)');
                downbtn.setAttribute('style', 'margin:1%;');

                var columnName = '';
                if (tcolumns[i - 1].indexOf('\"') < 0) {
                    // 컬럼명
                    columnName = document.createElement("text");
                    columnName.setAttribute('class', 'col' + i);
                    columnName.setAttribute('style', 'margin-Top: 1%;');
                    columnName.setAttribute('connector', tconnectors[conCount++]);
                    tcolumns[i - 1] =  tcolumns[i - 1].split('.')[0] + '.<span style="color:blue">' + tcolumns[i - 1].split('.')[1]+ '</span>';
                    columnName.innerHTML = tcolumns[i - 1];
                } else {
                    // 공통 데이터
                    columnName = document.createElement("input");
                    columnName.setAttribute('class', 'edit');
                    columnName.setAttribute('type', 'text');
                    columnName.setAttribute('style', 'width : 15%; padding : 5px; text-align: center;');
                    columnName.value = tcolumns[i - 1].substring(tcolumns[i - 1].indexOf('\"') + 1, tcolumns[i - 1].lastIndexOf('\"'));
                }

                div.append(upbtn);
                div.append(downbtn);
                div.append(columnName);

                // 첫번째줄과 마지막줄은 각각 위, 아래 버튼 비활성화
                if (i == 1) {
                    upbtn.setAttribute('disabled', 'disabled');
                }
                if (i == tcolumns.length) {
                    downbtn.setAttribute('disabled', 'disabled');
                }

                divAll.append(div);
            }
            // 추가 버튼
            var addbtn = document.createElement("button");
            addbtn.innerHTML = 'ADD';
            addbtn.setAttribute('onclick', 'columnAdd(this)');
            addbtn.setAttribute('style', 'margin:1%;');

            divAll.append(addbtn);

            modal.prepend(divAll);
            editText();

            modal.setStyle({
                padding: '2%',
                position: 'fixed',
                display: 'flex',
                boxShadow: '0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19)',

                // 시꺼먼 레이어 보다 한칸 위에 보이기
                zIndex: zIndex + 1,

                // div center 정렬
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                msTransform: 'translate(-50%, -50%)',
                webkitTransform: 'translate(-50%, -50%)'
            });
        }

        // Element 에 style 한번에 오브젝트로 설정하는 함수 추가
        Element.prototype.setStyle = function (styles) {
            for (var k in styles) this.style[k] = styles[k];
            return this;
        };

        // 모달창에서 UP 버튼 눌렀을 때
        function columnUp(button) {
            if (button.parentElement.getElementsByTagName('text').length != 0 && button.parentElement.previousElementSibling.getElementsByTagName('text').length != 0) {
                var tempText = button.parentElement.getElementsByTagName('text')[0];
                button.parentElement.getElementsByTagName('text')[0].replaceWith(button.parentElement.previousElementSibling.getElementsByTagName('text')[0]);
                button.parentElement.previousElementSibling.append(tempText);
            } else {
                temp = button.parentElement.lastElementChild;
                button.parentElement.lastElementChild.replaceWith(button.parentElement.previousElementSibling.lastElementChild);
                button.parentElement.previousElementSibling.append(temp);
            }
            editText();
        }

        // 모달창에서 DOWN 버튼 눌렀을 때
        function columnDown(button) {
            var temp = '';
            if (button.parentElement.getElementsByTagName('text').length != 0 && button.parentElement.nextElementSibling.getElementsByTagName('text').length != 0) {
                var tempText = button.parentElement.getElementsByTagName('text')[0];
                button.parentElement.getElementsByTagName('text')[0].replaceWith(button.parentElement.nextElementSibling.getElementsByTagName('text')[0]);
                button.parentElement.nextElementSibling.append(tempText);
            } else {
                temp = button.parentElement.lastElementChild;
                button.parentElement.lastElementChild.replaceWith(button.parentElement.nextElementSibling.lastElementChild);
                button.parentElement.nextElementSibling.append(temp);
            }
            editText();
        }

        // 모달창에서 ADD 버튼 눌렀을 때
        function columnAdd(button) {
            var divAll = button.parentElement;
            var div = document.createElement("div");

            // 위쪽 버튼
            var upbtn = document.createElement("button");
            upbtn.innerHTML = 'UP';
            upbtn.setAttribute('onclick', 'columnUp(this)');
            upbtn.setAttribute('style', 'margin:1%;');

            // 아래쪽 버튼
            var downbtn = document.createElement("button");
            downbtn.innerHTML = 'DOWN';
            downbtn.setAttribute('onclick', 'columnDown(this)');
            downbtn.setAttribute('style', 'margin:1%;');
            downbtn.setAttribute('disabled', 'disabled');

            // input type="text"
            var addText = document.createElement("input");
            addText.setAttribute('class', 'edit');
            addText.setAttribute('type', 'text');
            addText.setAttribute('style', 'width : 15%; padding : 5px; text-align: center;');

            div.append(upbtn);
            div.append(downbtn);
            div.append(addText);

            if (divAll.childElementCount > 1) {
                // 이미 만들어진 up, down 버튼이 있을 때            	
                divAll.children[divAll.childElementCount - 2].children[1].removeAttribute('disabled');
            } else {
                // 최초로 up, down 버튼을 만들 때 	
                upbtn.setAttribute('disabled', 'disabled');
            }

            divAll.lastElementChild.before(div);
        }

        // 변경되는 컬럼 위치에 맞춰서 컬럼명 출력 
        function editText() {
            var modal = document.getElementById('my_modal');
            var editText = document.getElementById('editText');
            var tempText = '';
            var length = modal.firstElementChild.childElementCount - 1;
            for (var i = 0; i < length; i++) {
                var now = modal.firstElementChild.childNodes[i];
                if (now.getElementsByTagName('text').length != 0) {
                    tempText += now.getElementsByTagName('text')[0].innerText.split('.')[0] + '.<span style="color:blue">' + now.getElementsByTagName('text')[0].innerText.split('.')[1] + '</span>' + '<span style="color:red"> | </span>';
                } else {
                    if (now.getElementsByTagName('input')[0].value == '') {
                        continue;
                    }
                    tempText += '\"' + now.getElementsByTagName('input')[0].value + '\" <span style="color:red">|</span> ';
                }
            }
            tempText = tempText.substring(0, tempText.lastIndexOf('|'));
            editText.innerHTML = tempText;
        }

        // 모달창에서 SAVE 버튼 눌렀을 때
        function columnSave() {
            // 모달 div 지우면서 해당 데이터 컬럼명으로 만들기
            var modal = document.getElementById('my_modal');
            var reduceText = '';
            var colText = '';
            var colCon = '';
            var length = modal.firstElementChild.childElementCount - 1;
            for (var i = 0; i < length; i++) {
                if (modal.firstElementChild.childNodes[i].getElementsByTagName('text').length != 0) {
                    colText += modal.firstElementChild.childNodes[i].getElementsByTagName('text')[0].innerText + '|';
                    colCon += modal.firstElementChild.childNodes[i].getElementsByTagName('text')[0].getAttribute('connector') + '|';
                } else {
                    if (modal.firstElementChild.childNodes[i].getElementsByTagName('input')[0].value == '') {
                        continue;
                    }
                    colText += '\"' + modal.firstElementChild.childNodes[i].getElementsByTagName('input')[0].value + '\"|';
                }
            }
            colText = colText.substring(0, colText.lastIndexOf('|'));
            colCon = colCon.substring(0, colCon.lastIndexOf('|'));

            if (colText != '') {
                reduceText = textReduce(colText);
                nowClickColumn.innerHTML = reduceText;
                nowClickColumn.parentElement.firstElementChild.children[2].setAttribute('columnName', colText);
                nowClickColumn.parentElement.firstElementChild.children[2].setAttribute('connectors', colCon);
            } else {
                // modal창에 입력할 데이터가 없을 때 초기값으로 설정
                var init = nowClickColumn.parentElement.firstElementChild.children[2].getAttribute('initCol');
                nowClickColumn.innerHTML = init;
                nowClickColumn.parentElement.firstElementChild.children[2].setAttribute('columnName', init);
            }

            modal.removeChild(modal.firstElementChild);
            document.body.lastElementChild.remove();
            modal.style.display = 'none';
        }

        // 모달창에서 CLOSE 버튼 눌렀을 때
        function columnClose() {
            // 모달 div 지우면서 해당 데이터 컬럼명으로 만들기
            var modal = document.getElementById('my_modal');
            var length = modal.childElementCount - 1;
            for (var i = 0; i < length; i++) {
                modal.removeChild(modal.firstElementChild);
            }
            document.body.lastElementChild.remove();
            modal.style.display = 'none';
        }
    </script>
</head>

<body>
    <!-- 컬럼명 클릭했을때 나타나는 모달창 -->
    <div id="my_modal" style="height: auto; width: 80%; overflow-y: auto; max-height: 80%;">
        <div style="flex: 1;  display: flex; flex-direction: column;">
            <text id="editText"></text>
            <div id="btn_modal" style="margin-left: auto; margin-top : auto;">
                <button class="modal_save_btn" onclick="columnSave()">SAVE</button>
                <button class="modal_close_btn" onclick="columnClose()">CLOSE</button>
            </div>
        </div>
    </div>

    <div id="searchInterface" align="center" contenteditable="false">
        <input class="interfaceListInput" type="text" name="interfaceListInput" list="interfaceList"
            style="width: 250px; height: 30px; border-radius: 5px; margin-left: 50px;">
        <datalist id="interfaceList"></datalist>
        <button id="saveBtn" style="visibility: hidden;" onclick="saveData()">SAVE</button>
        <button id="clearBtn" style="visibility: hidden;" onclick="clearData()">CLEAR</button>
    </div>
    <div class="svgScroll" id="svgScroll">
        <svg id="svg" style="visibility: hidden;">
            <text contenteditable="true" required="true"></text>
            <g id="diagram" data-drag="diagram:diagram" data-drag-type="diagram">
                <g id="node-layer">
                    <!-- PROCESS 1 -->
                    <g class="node-container">
                        <rect class="node-background" width="254" height="128" x="0" y="0" rx="6" ry="6"></rect>
                        <g class="node-header">
                            <rect class="header-round-rect" width="250" height="40" x="2" y="2" rx="4" ry="4"></rect>
                            <rect class="header-rect" width="250" height="36" x="2" y="6"></rect>
                            <text class="header-title" x="122" y="30">Process 1</text>
                        </g>
                        <g class="node-content">
                            <rect class="content-round-rect" width="250" height="82" x="2" y="44" rx="4" ry="4"></rect>
                            <rect class="content-rect" width="250" height="77" x="2" y="44"></rect>
                            <g class="outputs"></g>
                        </g>
                    </g>
                    <!-- PROCESS 2 -->
                    <g class="node-container">
                        <rect class="node-background" width="874" height="128" x="0" y="0" rx="6" ry="6"></rect>
                        <g class="node-header">
                            <rect class="header-round-rect" width="870" height="40" x="2" y="2" rx="4" ry="4"></rect>
                            <rect class="header-rect" width="870" height="36" x="2" y="6"></rect>
                            <text class="header-title" x="102" y="30">Process 2</text>
                        </g>
                        <g class="node-content">
                            <rect class="content-round-rect" width="870" height="82" x="2" y="44" rx="4" ry="4"></rect>
                            <rect class="content-rect" width="870" height="77" x="2" y="44"></rect>
                            <g class="inputs"></g>
                            <g class="outputs"></g>
                        </g>
                    </g>
                </g>
                <g id="connections-layer"></g>
                <g class="connector">
                    <path class="connector-path-outline"></path>
                    <path class="connector-path"></path>
                    <circle class="connector-handle input-handle" cx="0" cy="0" r="4"></circle>
                    <circle class="connector-handle output-handle" cx="0" cy="0" r="4"></circle>
                </g>
                <g id="tableconnections-layer"></g>
                <g class="tableconnector">
                    <path class="tableconnector-path-outline"></path>
                    <path class="tableconnector-path"></path>
                    <circle class="tableconnector-handle tableinput-handle" cx="0" cy="0" r="4"></circle>
                    <circle class="tableconnector-handle tableoutput-handle" cx="0" cy="0" r="4"></circle>
                </g>
                <circle id="drag-proxy" cx="0" cy="0" r="1" fill="none"></circle>
            </g>
        </svg>
    </div>
</body>
</html>
